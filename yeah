local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")
local SoundService = game:GetService("SoundService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()
local camera = Workspace.CurrentCamera

-- Theme Storage for Settings
local Theme = {
    AccentColor = Color3.fromRGB(138, 43, 226), -- Purple
    BackgroundColor = Color3.fromRGB(20, 20, 20), -- Dark Grey
    SurfaceColor = Color3.fromRGB(24, 24, 24), -- Slightly lighter dark grey
    BorderColor = Color3.fromRGB(56, 56, 56), -- Grey
    PrimaryText = Color3.fromRGB(255, 255, 255), -- White
    SecondaryText = Color3.fromRGB(180, 180, 180), -- Light Grey
    ButtonColor = Color3.fromRGB(30, 30, 30), -- Even lighter dark grey
    Font = Enum.Font.GothamSemibold,

    -- Customization options (defaults updated, will be adjustable via UI)
    GlowColor = Color3.fromRGB(138, 43, 226),
    NotificationColor = Color3.fromRGB(138, 43, 226),
    WatermarkColor = Color3.fromRGB(138, 43, 226),
    WatermarkPinkColor = Color3.fromRGB(255, 105, 180), -- For .lol
    SliderFillColor = Color3.fromRGB(138, 43, 226),
    ToggleActiveColor = Color3.fromRGB(138, 43, 226),
    DropdownColor = Color3.fromRGB(30, 30, 30),
    ColorPickerBorder = Color3.fromRGB(56, 56, 56),
    CloseButtonColor = Color3.fromRGB(255, 50, 50),

    -- ESP Colors (initial defaults, will be adjustable)
    ESPBoxColor = Color3.fromRGB(255, 255, 255),
    ESPBoxGlowColor = Color3.fromRGB(255, 255, 255),
    ESPNameColor = Color3.fromRGB(255, 255, 255),
    ESPNameOutlineColor = Color3.fromRGB(0, 0, 0),
    ESPNameGlowColor = Color3.fromRGB(255, 255, 255),
    ESPHealthBarBGColor = Color3.fromRGB(50, 50, 50),
    ESPHealthBarColor = Color3.fromRGB(0, 255, 0),
    ESPHealthBarOutlineColor = Color3.fromRGB(0, 0, 0),
    ESPHealthBarGlowColor = Color3.fromRGB(0, 255, 0),
    ESPHealthNumberColor = Color3.fromRGB(255, 255, 255),
    ESPToolColor = Color3.fromRGB(255, 255, 0),
    ESPToolOutlineColor = Color3.fromRGB(0, 0, 0),
    ESPToolGlowColor = Color3.fromRGB(255, 255, 0),
    ESPDistanceColor = Color3.fromRGB(255, 255, 255),
    ESPDistanceOutlineColor = Color3.fromRGB(0, 0, 0),
    ESPDistanceGlowColor = Color3.fromRGB(255, 255, 255),
    ESPChamsColor = Color3.fromRGB(255, 0, 0),
    ESPChamsGlowColor = Color3.fromRGB(255, 0, 0),
    ESPSkeletonColor = Color3.fromRGB(255, 255, 255),
    ESPSkeletonGlowColor = Color3.fromRGB(255, 255, 255),

    SelfESPBoxColor = Color3.fromRGB(0, 255, 255),
    SelfESPBoxGlowColor = Color3.fromRGB(0, 255, 255),
    SelfESPNameColor = Color3.fromRGB(0, 255, 255),
    SelfESPNameOutlineColor = Color3.fromRGB(0, 0, 0),
    SelfESPNameGlowColor = Color3.fromRGB(0, 255, 255),
    SelfESPHealthBarBGColor = Color3.fromRGB(50, 50, 50),
    SelfESPHealthBarColor = Color3.fromRGB(0, 255, 255),
    SelfESPHealthBarOutlineColor = Color3.fromRGB(0, 0, 0),
    SelfESPHealthBarGlowColor = Color3.fromRGB(0, 255, 255),
    SelfESPHealthNumberColor = Color3.fromRGB(255, 255, 255),
    SelfESPToolColor = Color3.fromRGB(0, 255, 255),
    SelfESPToolOutlineColor = Color3.fromRGB(0, 0, 0),
    SelfESPToolGlowColor = Color3.fromRGB(0, 255, 255),
    SelfESPDistanceColor = Color3.fromRGB(0, 255, 255),
    SelfESPDistanceOutlineColor = Color3.fromRGB(0, 0, 0),
    SelfESPDistanceGlowColor = Color3.fromRGB(0, 255, 255),
    SelfESPChamsColor = Color3.fromRGB(0, 255, 255),
    SelfESPChamsGlowColor = Color3.fromRGB(0, 255, 255),
    SelfESPSkeletonColor = Color3.fromRGB(0, 255, 255),
    SelfESPSkeletonGlowColor = Color3.fromRGB(0, 255, 255),

    WorldAmbienceColor = Color3.fromRGB(255, 255, 255),
    WorldAmbienceGlowColor = Color3.fromRGB(255, 255, 255),
    WorldBuildingColor = Color3.fromRGB(255, 255, 255),
    WorldBuildingGlowColor = Color3.fromRGB(255, 255, 255),
    WorldFogColor = Color3.fromRGB(255, 255, 255),
    WorldFogGlowColor = Color3.fromRGB(255, 255, 255),
    WorldScreenColor = Color3.fromRGB(255, 255, 255),

    EffectSelfBulletTracerColor = Color3.fromRGB(255, 255, 0),
    EffectEnemyBulletTracerColor = Color3.fromRGB(255, 0, 0),
    EffectHitSkeletonColor = Color3.fromRGB(255, 0, 0),
    EffectHitSkeletonGlowColor = Color3.fromRGB(255, 0, 0),
    EffectCrosshairColor = Color3.fromRGB(255, 255, 255),
    EffectCrosshairOutlineColor = Color3.fromRGB(0, 0, 0),

    TargetTracerColor = Color3.fromRGB(255, 0, 0),
    TargetHeadDotColor = Color3.fromRGB(255, 0, 0),
    TargetInfoBoxColor = Color3.fromRGB(255, 255, 255),
    TargetGlowChamsColor = Color3.fromRGB(255, 0, 0),

    FOVOutlineColor = Color3.fromRGB(255, 255, 255),
    FOVFillColor = Color3.fromRGB(255, 255, 255),
    SilentFOVOutlineColor = Color3.fromRGB(255, 255, 255),
    SilentFOVFillColor = Color3.fromRGB(255, 255, 255),
}

-- Settings Table (Centralized State Management) - ALL OFF BY DEFAULT
local Settings = {
    ShowWatermark = false,
    ShowNotifications = false,
    GlowEnabled = false,
    WatermarkText = "Script FFA | Player: [PLAYERNAME] | FPS: [FPS]",
    NotificationType = "Modern",
    WatermarkMode = "Normal", -- "Normal", "Discord", "Fuju"

    -- Combat Settings
    Combat = {
        Enable = false,
        Hotkey = Enum.KeyCode.E,
        UseChecks = false,
        Checks = {
            TeamCheck = false,
            WallCheck = false,
            RaycastIgnoreList = {},
            TargetFriends = false,
        },
        TargetMethod = "Closest",
        UseSmoothness = false,
        XSmoothnessAmount = 5,
        YSmoothnessAmount = 5,
        UsePrediction = false,
        XPredictionAmount = 0.15,
        YPredictionAmount = 0.15,
        UseCustomOffset = false,
        XOffset = 0,
        YOffset = 0,
        HitPart = "HumanoidRootPart", -- Default to HumanoidRootPart to be safe
        AimType = "Mouse", -- Changed from ClientSided
        
        FOV = {
            UseFOV = false,
            DrawFOV = false,
            FillFOV = false,
            FOVSize = 125,
            FOVTransparencyFill = 0.5,
            FOVTransparencyOutline = 0,
        },

        -- Silent Aim
        SilentAim = {
            Enable = false,
            Hotkey = Enum.KeyCode.Q,
            HitParts = {"Head"}, -- Multiple selection
            HitChanceToggle = false,
            HitChance = 100,
            WallCheck = false,
            TeamCheck = false,
            FOV = {
                UseFOV = false,
                DrawFOV = false,
                FillFOV = false,
                FOVSize = 125,
                FOVTransparencyFill = 0.5,
                FOVTransparencyOutline = 0,
            },
        },

        -- Orbit Lock
        OrbitLock = {
            Enable = false,
            Hotkey = Enum.KeyCode.F,
            HitPart = "HumanoidRootPart",
            LookAtTarget = false,
            Spectate = false,
            OrbitPlacement = "Default", -- Placeholder
            XOffset = 0,
            YOffset = 0,
            Radius = 15,
            Speed = 2,
            ResetOffset = false,
        },

        -- Fun Features
        HitNotification = false,
        HitSound = "None",
        TargetTracer = false,
        TargetHeadDot = false,
        TargetInfoBox = false,
        TargetGlowChams = false,
    },

    -- Visuals Settings
    Visuals = {
        ESP = {
            Enable = false,
            Distance = 500,
            BoxESP = false,
            BoxType = "Normal",
            BoxGlow = false,
            NameESP = false,
            NameOutline = false,
            NameGlow = false,
            HealthBarESP = false,
            HealthNumber = false,
            HealthBarOutline = false,
            HealthBarGlow = false,
            ToolESP = false,
            ToolOutline = false,
            ToolGlow = false,
            DistanceESP = false,
            DistanceOutline = false,
            DistanceGlow = false,
            ChamsESP = false,
            ChamsGlow = false,
            SkeletonESP = false,
            SkeletonGlow = false,
            GlowIntensity = 50,
        },

        SelfESP = {
            Enable = false,
            Distance = 500, -- Added for consistency
            BoxESP = false,
            BoxType = "Normal",
            BoxGlow = false,
            NameESP = false,
            NameOutline = false,
            NameGlow = false,
            HealthBarESP = false,
            HealthNumber = false,
            HealthBarOutline = false,
            HealthBarGlow = false,
            ToolESP = false,
            ToolOutline = false,
            ToolGlow = false,
            DistanceESP = false,
            DistanceOutline = false,
            DistanceGlow = false,
            ChamsESP = false,
            ChamsGlow = false,
            -- No skeleton for self ESP as per user request
            GlowIntensity = 50, -- Added for consistency
        },

        World = {
            AmbienceColorToggle = false,
            BuildingColorToggle = false,
            FogColorToggle = false,
            FogStart = 0,
            FogEnd = 10000,
            ScreenColorOverlayToggle = false,
            AmbienceGlow = false,
            BuildingGlow = false,
            FogGlow = false,
        },

        Effects = {
            SnowFlakes = false,
            HelloKitty = false,
            SelfBulletTracer = false,
            EnemyBulletTracer = false,
            BulletStartSize = 1,
            BulletEndSize = 1,
            BulletDuration = 1,
            HitSkeleton = false,
            HitSkeletonGlow = false,
            Crosshair = false,
            CrosshairOutline = false,
            CrosshairGap = 5,
            CrosshairSize = 10,
            CrosshairSpin = false,
            CrosshairSpinSpeed = 5
        }
    },

    -- Misc Settings
    Misc = {
        Fly = {
            Enable = false,
            Hotkey = Enum.KeyCode.Space,
            Speed = 25,
            Type = "Normal",
        },

        Speed = {
            Enable = false,
            Hotkey = Enum.KeyCode.LeftControl,
            Amount = 25,
            Type = "Legit",
            LegitSlideAmount = 10,
        },

        AntiAim = {
            Enable = false,
            Type = "None", -- Placeholder for types
            Pitch = "None",
            Yaw = "None",
            RealOffset = 0,
            FakeOffset = 0,
            SpinSpeed = 10,
            -- Add more anti-aim specific settings as needed.
            -- For example:
            LookAtTarget = false,
            Jitter = false,
            JitterAmount = 10,
            Spins = false,
            SpinSpeed = 100,
            LBYBreaker = false,
            LBYOffset = 180,
            FakeWalk = false,
            FakeWalkSpeed = 5,
        },

        Players = {
            SpectatePlayer = nil,
            TeleportToPlayer = nil,
            FlingPlayer = nil,
        }
    },

    -- Internal Settings (UI, Configs)
    Settings = {
        UI = {
            Font = Enum.Font.GothamSemibold,
            BackgroundTransparency = 0,
            ShowWatermark = false,
            ShowNotifications = false,

            -- UI Element Colors (initial, will be linked to color pickers)
            AccentColor = Theme.AccentColor,
            BackgroundColor = Theme.BackgroundColor,
            SurfaceColor = Theme.SurfaceColor,
            BorderColor = Theme.BorderColor,
            PrimaryText = Theme.PrimaryText,
            SecondaryText = Theme.SecondaryText,
            ButtonColor = Theme.ButtonColor,
            SliderFillColor = Theme.SliderFillColor,
            ToggleActiveColor = Theme.ToggleActiveColor,
            DropdownColor = Theme.DropdownColor,
            CloseButtonColor = Theme.CloseButtonColor,
            WatermarkColor = Theme.WatermarkColor,
            WatermarkPinkColor = Theme.WatermarkPinkColor,
            NotificationColor = Theme.NotificationColor,
            GlowColor = Theme.GlowColor,
            -- New UI specific colors for all elements
            TabActiveColor = Theme.AccentColor,
            TabInactiveColor = Theme.SurfaceColor,
            SubTabActiveColor = Theme.ButtonColor,
            SubTabInactiveColor = Theme.BackgroundColor,
            SectionHeaderColor = Theme.AccentColor,
            TextBoxOutlineColor = Theme.BorderColor,
            TextBoxFillColor = Theme.ButtonColor,
            HotKeyButtonColor = Theme.ButtonColor,
        },

        Config = {
            Current = "Default",
            List = {"Default"},
            CreateConfig = false,
            LoadConfig = false,
            ConfigName = "NewConfig",
            DeleteConfig = false,
        },

        Hotkeys = {}
    }
}

-- Mapping of Enum.PartType to readable names for dropdown
local PART_NAMES = {
    "Head", "HumanoidRootPart", "Torso", "UpperTorso", "LowerTorso",
    "Left Arm", "Right Arm", "Left Leg", "Right Leg",
    "LeftHand", "RightHand", "LeftFoot", "RightFoot",
    "Neck", "Waist", "RightUpperArm", "LeftUpperArm", "RightLowerArm", "LeftLowerArm",
    "RightUpperLeg", "LeftUpperLeg", "RightLowerLeg", "LeftLowerLeg"
}

-- Sound IDs for Hit Sounds
local HIT_SOUND_IDS = {
    None = nil,
    Rust = "rbxassetid://96170170666605",
    Neverlose = "rbxassetid://97643101798871",
    MW2019 = "rbxassetid://7172056822",
    Coin1 = "rbxassetid://6792279908",
    Coin2 = "rbxassetid://3125624765",
    RustHeadshot = "rbxassetid://5043539486", -- New sound ID
    Ding = "rbxassetid://XXXXX" -- Placeholder, user only specified "ding" not an ID.
}

-- Effect IDs for falling effects
local SNOWFLAKE_EFFECT_ID = "rbxassetid://88697899861401"
local HELLO_KITTY_EFFECT_ID = "rbxassetid://119561339599069"

-- ESP Storage (for custom drawing)
local ESPContainer = create("ScreenGui", {
    Name = "ESPGui",
    DisplayOrder = 99,
    ResetOnSpawn = false,
    ZIndexBehavior = "Global",
    Parent = CoreGui
})
local ESPObjects = {} -- Stores active ESP GUI elements by player
local FOVCircle = nil
local SilentFOVCircle = nil

-- Current target (for Aimbot, Silent Aim, etc.)
local currentTarget = nil
local lockedTarget = nil
local orbitAngle = 0

-- Store original game properties to revert later
local originalGravity = Workspace.Gravity
local originalWalkSpeed = 16
local originalJumpPower = 50
local originalJumpHeight = 7.2 -- Default jump height
local originalTransparency = nil

-- Update original values on character spawn
player.CharacterAdded:Connect(function(char)
    local humanoid = char:WaitForChild("Humanoid")
    originalWalkSpeed = humanoid.WalkSpeed
    originalJumpPower = humanoid.JumpPower
end)


-- Utility functions (no -- notes)
local function create(instance, properties)
    local ins = Instance.new(instance)
    for property, value in pairs(properties) do
        ins[property] = value
    end
    return ins
end

local function round(n, d)
    local multiplier = 10 ^ (d or 0)
    return math.floor(n * multiplier + 0.5) / multiplier
end

local function toHex(color)
    return string.format("#%02X%02X%02X", color.R * 255, color.G * 255, color.B * 255)
end

local function fromHex(hex)
    local r, g, b = string.match(hex, "^#?(%x%x)(%x%x)(%x%x)$")
    if r and g and b then
        return Color3.fromRGB(tonumber(r, 16), tonumber(g, 16), tonumber(b, 16))
    end
    return Color3.fromRGB(255, 255, 255)
end

local function HSVtoRGB(h, s, v)
    local r, g, b
    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)
    i = i % 6
    if i == 0 then r, g, b = v, t, p
    elseif i == 1 then r, g, b = q, v, p
    elseif i == 2 then r, g, b = p, v, t
    elseif i == 3 then r, g, b = p, q, v
    elseif i == 4 then r, g, b = t, p, v
    elseif i == 5 then r, g, b = v, p, q
    end
    return Color3.fromRGB(r * 255, g * 255, b * 255)
end

local function RGBtoHSV(color)
    local r, g, b = color.R, color.G, color.B
    local max = math.max(r, g, b)
    local min = math.min(r, g, b)
    local h, s, v
    v = max
    local d = max - min
    s = max == 0 and 0 or d / max
    if max == min then h = 0
    else
        if max == r then h = (g - b) / d + (g < b and 6 or 0)
        elseif max == g then h = (b - r) / d + 2
        elseif max == b then h = (r - g) / d + 4
        end
        h = h / 6
    end
    return h, s, v
end

local function isVisuallyObscured(partA, partB, ignoreList)
    if not partA or not partB then return true end
    local origin = partA.Position
    local direction = (partB.Position - origin).Unit * ((partA.Position - partB.Position).Magnitude + 1) -- Add a small buffer

    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = {player.Character}
    if ignoreList then
        for _, v in ipairs(ignoreList) do
            table.insert(raycastParams.FilterDescendantsInstances, v)
        end
    end
    raycastParams.IgnoreWater = true

    local result = Workspace:Raycast(origin, direction, raycastParams)
    return result and result.Instance and not (result.Instance:IsDescendantOf(partB.Parent) or result.Instance == partB)
end


-- Drag functionality
local function makeDraggable(frame, dragHandle)
    local dragging = false
    local dragStartPos
    local initialFramePos

    dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStartPos = input.Position
            initialFramePos = frame.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.Ended then
                    dragging = false
                end
            end)
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and dragging then
            local delta = input.Position - dragStartPos
            local newX = initialFramePos.X.Offset + delta.X
            local newY = initialFramePos.Y.Offset + delta.Y
            frame.Position = UDim2.new(initialFramePos.X.Scale, newX, initialFramePos.Y.Scale, newY)
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and dragging then
            dragging = false
        end
    end)
end


-- UI Element Creation Functions
local function createSection(parent, name, height)
    local sectionFrame = create("Frame", {
        Name = name .. "Section",
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, height or 150),
        AutomaticSize = (not height and Enum.AutomaticSize.Y) or Enum.AutomaticSize.None, -- Only automatic if height not specified
        LayoutOrder = 1,
        Parent = parent
    })

    create("UIPadding", {
        PaddingTop = UDim.new(0, 5),
        PaddingBottom = UDim.new(0, 5),
        PaddingLeft = UDim.new(0, 10),
        PaddingRight = UDim.new(0, 10),
        Parent = sectionFrame
    })

    local sectionLayout = create("UIListLayout", {
        FillDirection = Enum.FillDirection.Vertical,
        HorizontalAlignment = Enum.HorizontalAlignment.Left,
        Padding = UDim.new(0, 5),
        Parent = sectionFrame
    })

    local header = create("Frame", {
        Name = "Header",
        BackgroundColor3 = Settings.Settings.UI.SectionHeaderColor,
        BackgroundTransparency = 0.8,
        Size = UDim2.new(1, 0, 0, 20),
        Parent = sectionFrame
    })

    create("TextLabel", {
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 1, 0),
        Text = name,
        TextColor3 = Settings.Settings.UI.PrimaryText,
        TextSize = 13,
        Font = Settings.Settings.UI.Font,
        TextXAlignment = Enum.TextXAlignment.Left,
        Position = UDim2.new(0, 5, 0, 0),
        Parent = header
    })

    return sectionFrame
end

local function createToggle(parent, name, defaultValue, callback)
    local toggleHolder = create("Frame", {
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 25),
        Parent = parent
    })

    local toggleButton = create("TextButton", {
        Name = "Toggle",
        BackgroundColor3 = Settings.Settings.UI.ButtonColor,
        BorderColor3 = Settings.Settings.UI.BorderColor,
        BorderSizePixel = 1,
        Size = UDim2.new(1, 0, 1, 0),
        Text = "",
        Parent = toggleHolder
    })

    local toggleText = create("TextLabel", {
        Name = "Text",
        BackgroundTransparency = 1,
        Size = UDim2.new(1, -30, 1, 0),
        Position = UDim2.new(0, 5, 0, 0),
        Text = name,
        TextColor3 = Settings.Settings.UI.PrimaryText,
        TextSize = 12,
        Font = Settings.Settings.UI.Font,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = toggleButton
    })

    local toggleIndicator = create("ImageLabel", {
        Name = "Indicator",
        BackgroundTransparency = 1,
        Size = UDim2.new(0, 20, 0, 20),
        Position = UDim2.new(1, -25, 0.5, -10),
        Image = "rbxassetid://3926305904", -- Checkbox image asset
        ImageRectSize = Vector2.new(24, 24),
        Parent = toggleButton
    })

    local currentValue = defaultValue
    local function updateToggleVisual()
        if currentValue then
            toggleIndicator.ImageRectOffset = Vector2.new(28, 4) -- Checked
            toggleIndicator.ImageColor3 = Settings.Settings.UI.ToggleActiveColor
        else
            toggleIndicator.ImageRectOffset = Vector2.new(4, 4) -- Unchecked
            toggleIndicator.ImageColor3 = Settings.Settings.UI.PrimaryText
        end
    end

    toggleButton.MouseButton1Click:Connect(function()
        currentValue = not currentValue
        updateToggleVisual()
        if callback then callback(currentValue) end
        showNotification(name, currentValue and "Enabled" or "Disabled", 1)
    end)

    updateToggleVisual()
    return toggleHolder, function() return currentValue end, function(value) currentValue = value updateToggleVisual() end
end

local function createToggleWithHotkey(parent, name, defaultValue, defaultHotkey, callback)
    local toggleHolder, getToggle, setToggle = createToggle(parent, name, defaultValue, callback)

    local hotkeyButton = create("TextButton", {
        Name = "HotkeyButton",
        BackgroundColor3 = Settings.Settings.UI.HotKeyButtonColor,
        BorderColor3 = Settings.Settings.UI.BorderColor,
        BorderSizePixel = 1,
        Size = UDim2.new(0, 70, 0, 20),
        Position = UDim2.new(1, -80, 0.5, -10),
        Text = defaultHotkey.Name,
        TextColor3 = Settings.Settings.UI.PrimaryText,
        TextSize = 12,
        Font = Settings.Settings.UI.Font,
        Parent = toggleHolder
    })

    local currentHotkey = defaultHotkey
    local listeningForKey = false

    local function updateHotkeyText()
        hotkeyButton.Text = currentHotkey.Name
    end

    hotkeyButton.MouseButton1Click:Connect(function()
        if listeningForKey then return end
        listeningForKey = true
        hotkeyButton.Text = "..."
        local inputConnection = nil
        inputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
            if not gameProcessedEvent and input.UserInputType == Enum.UserInputType.Keyboard then
                currentHotkey = input.KeyCode
                updateHotkeyText()
                if callback then callback(getToggle(), currentHotkey) end -- Pass toggle state and new hotkey
                showNotification(name .. " Hotkey", "Set to: " .. currentHotkey.Name, 1.5)
                listeningForKey = false
                inputConnection:Disconnect()
            end
        end)
    end)

    -- Override the toggle's callback to also pass the hotkey
    local originalToggleCallback = callback
    callback = function(value)
        if originalToggleCallback then originalToggleCallback(value, currentHotkey) end
    end
    -- Need to re-set the toggle callback if createToggle returns functions.
    -- For now, directly modify internal state if createToggle uses external update.

    return toggleHolder, getToggle, setToggle, function() return currentHotkey end, function(key) currentHotkey = key updateHotkeyText() end
end


local function createSlider(parent, name, min, max, defaultValue, step, callback)
    local sliderHolder = create("Frame", {
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 40),
        Parent = parent
    })

    local sliderLabel = create("TextLabel", {
        BackgroundTransparency = 1,
        Size = UDim2.new(1, -70, 0, 15),
        Position = UDim2.new(0, 0, 0, 0),
        Font = Settings.Settings.UI.Font,
        Text = name,
        TextColor3 = Settings.Settings.UI.PrimaryText,
        TextSize = 12,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = sliderHolder
    })

    local valueLabel = create("TextLabel", {
        BackgroundTransparency = 1,
        Size = UDim2.new(0, 60, 0, 15),
        Position = UDim2.new(1, -60, 0, 0),
        Font = Settings.Settings.UI.Font,
        Text = tostring(defaultValue),
        TextColor3 = Settings.Settings.UI.SecondaryText,
        TextSize = 12,
        TextXAlignment = Enum.TextXAlignment.Right,
        Parent = sliderHolder
    })

    local sliderTrack = create("Frame", {
        BackgroundColor3 = Settings.Settings.UI.ButtonColor,
        BorderColor3 = Settings.Settings.UI.BorderColor,
        BorderSizePixel = 1,
        Size = UDim2.new(1, 0, 0, 5),
        Position = UDim2.new(0, 0, 0, 20),
        Parent = sliderHolder
    })

    local sliderFill = create("Frame", {
        BackgroundColor3 = Settings.Settings.UI.SliderFillColor,
        Size = UDim2.new(0, 0, 1, 0),
        Parent = sliderTrack
    })

    local sliderThumb = create("Frame", {
        BackgroundColor3 = Settings.Settings.UI.AccentColor,
        BorderColor3 = Settings.Settings.UI.BorderColor,
        BorderSizePixel = 1,
        Size = UDim2.new(0, 10, 0, 15),
        Position = UDim2.new(0, 0, 0.5, -7),
        Parent = sliderTrack
    })

    local currentValue = defaultValue

    local function updateSliderVisual()
        local percentage = (currentValue - min) / (max - min)
        sliderFill.Size = UDim2.new(percentage, 0, 1, 0)
        sliderThumb.Position = UDim2.new(percentage, 0, 0.5, -7)
        valueLabel.Text = tostring(round(currentValue, (string.len(tostring(step)) - string.find(tostring(step), "%.", 1, true)) or 0))
    end

    local dragging = false
    sliderThumb.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and dragging then
            local mouseX = input.Position.X
            local relativeX = mouseX - sliderTrack.AbsolutePosition.X
            local normalizedX = math.max(0, math.min(1, relativeX / sliderTrack.AbsoluteSize.X))
            local newValue = min + normalizedX * (max - min)
            currentValue = math.floor(newValue / step + 0.5) * step -- Snap to step
            updateSliderVisual()
            if callback then callback(currentValue) end
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and dragging then
            dragging = false
            showNotification(name, "Set to: " .. tostring(round(currentValue, (string.len(tostring(step)) - string.find(tostring(step), "%.", 1, true)) or 0)), 1)
        end
    end)

    updateSliderVisual()
    return sliderHolder, function() return currentValue end, function(value) currentValue = value updateSliderVisual() end
end

local function createDropdown(parent, name, options, defaultValue, callback)
    local dropdownHolder = create("Frame", {
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 25),
        Parent = parent
    })

    local dropdownButton = create("TextButton", {
        Name = "DropdownButton",
        BackgroundColor3 = Settings.Settings.UI.ButtonColor,
        BorderColor3 = Settings.Settings.UI.BorderColor,
        BorderSizePixel = 1,
        Size = UDim2.new(1, 0, 1, 0),
        Text = "",
        Font = Settings.Settings.UI.Font,
        TextColor3 = Settings.Settings.UI.PrimaryText,
        TextSize = 12,
        TextXAlignment = Enum.TextXAlignment.Left,
        Position = UDim2.new(0, 0, 0, 0),
        Parent = dropdownHolder
    })

    create("TextLabel", {
        BackgroundTransparency = 1,
        Size = UDim2.new(1, -30, 1, 0),
        Position = UDim2.new(0, 5, 0, 0),
        Text = name,
        TextColor3 = Settings.Settings.UI.PrimaryText,
        TextSize = 12,
        Font = Settings.Settings.UI.Font,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = dropdownButton
    })

    local selectedTextLabel = create("TextLabel", {
        BackgroundTransparency = 1,
        Size = UDim2.new(0, 70, 1, 0),
        Position = UDim2.new(1, -75, 0, 0),
        Text = defaultValue,
        TextColor3 = Settings.Settings.UI.SecondaryText,
        TextSize = 12,
        Font = Settings.Settings.UI.Font,
        TextXAlignment = Enum.TextXAlignment.Right,
        Parent = dropdownButton
    })

    local dropdownList = create("Frame", {
        Name = "DropdownList",
        BackgroundColor3 = Settings.Settings.UI.DropdownColor,
        BorderColor3 = Settings.Settings.UI.BorderColor,
        BorderSizePixel = 1,
        Size = UDim2.new(1, 0, 0, #options * 20),
        Position = UDim2.new(0, 0, 0, 25),
        Visible = false,
        ZIndex = 2,
        Parent = dropdownHolder
    })

    local listLayout = create("UIListLayout", {
        FillDirection = Enum.FillDirection.Vertical,
        HorizontalAlignment = Enum.HorizontalAlignment.Left,
        Parent = dropdownList
    })

    local currentValue = defaultValue

    local function updateSelectedText()
        selectedTextLabel.Text = currentValue
    end

    for _, option in ipairs(options) do
        local optionButton = create("TextButton", {
            Name = option .. "Option",
            BackgroundColor3 = Settings.Settings.UI.DropdownColor,
            BackgroundTransparency = 0.5,
            Size = UDim2.new(1, 0, 0, 20),
            Text = option,
            TextColor3 = Settings.Settings.UI.PrimaryText,
            TextSize = 12,
            Font = Settings.Settings.UI.Font,
            TextXAlignment = Enum.TextXAlignment.Left,
            Position = UDim2.new(0, 5, 0, 0),
            Parent = dropdownList
        })

        optionButton.MouseButton1Click:Connect(function()
            currentValue = option
            updateSelectedText()
            dropdownList.Visible = false
            if callback then callback(currentValue) end
            showNotification(name, "Set to: " .. currentValue, 1)
        end)
    end

    dropdownButton.MouseButton1Click:Connect(function()
        dropdownList.Visible = not dropdownList.Visible
    end)

    updateSelectedText()
    return dropdownHolder, function() return currentValue end, function(value) currentValue = value updateSelectedText() end
end

local function createMultiSelectDropdown(parent, name, options, defaultValues, callback)
    local dropdownHolder = create("Frame", {
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 25),
        Parent = parent
    })

    local dropdownButton = create("TextButton", {
        Name = "DropdownButton",
        BackgroundColor3 = Settings.Settings.UI.ButtonColor,
        BorderColor3 = Settings.Settings.UI.BorderColor,
        BorderSizePixel = 1,
        Size = UDim2.new(1, 0, 1, 0),
        Text = "",
        Font = Settings.Settings.UI.Font,
        TextColor3 = Settings.Settings.UI.PrimaryText,
        TextSize = 12,
        TextXAlignment = Enum.TextXAlignment.Left,
        Position = UDim2.new(0, 0, 0, 0),
        Parent = dropdownHolder
    })

    create("TextLabel", {
        BackgroundTransparency = 1,
        Size = UDim2.new(1, -30, 1, 0),
        Position = UDim2.new(0, 5, 0, 0),
        Text = name,
        TextColor3 = Settings.Settings.UI.PrimaryText,
        TextSize = 12,
        Font = Settings.Settings.UI.Font,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = dropdownButton
    })

    local selectedTextLabel = create("TextLabel", {
        BackgroundTransparency = 1,
        Size = UDim2.new(0, 70, 1, 0),
        Position = UDim2.new(1, -75, 0, 0),
        Text = "",
        TextColor3 = Settings.Settings.UI.SecondaryText,
        TextSize = 10,
        TextXAlignment = Enum.TextXAlignment.Right,
        TextWrapped = true,
        Parent = dropdownButton
    })

    local dropdownList = create("Frame", {
        Name = "DropdownList",
        BackgroundColor3 = Settings.Settings.UI.DropdownColor,
        BorderColor3 = Settings.Settings.UI.BorderColor,
        BorderSizePixel = 1,
        Size = UDim2.new(1, 0, 0, #options * 20),
        Position = UDim2.new(0, 0, 0, 25),
        Visible = false,
        ZIndex = 2,
        Parent = dropdownHolder
    })

    local listLayout = create("UIListLayout", {
        FillDirection = Enum.FillDirection.Vertical,
        HorizontalAlignment = Enum.HorizontalAlignment.Left,
        Parent = dropdownList
    })

    local selectedValues = {}
    for _, val in ipairs(defaultValues) do
        table.insert(selectedValues, val)
    end

    local function updateSelectedText()
        if #selectedValues == 0 then
            selectedTextLabel.Text = "None"
        else
            selectedTextLabel.Text = table.concat(selectedValues, ", ")
        end
    end

    local function updateOptionState()
        for _, optionFrame in ipairs(dropdownList:GetChildren()) do
            if optionFrame:IsA("TextButton") then
                local optionName = optionFrame.Name:gsub("Option", "")
                local optionToggleIndicator = optionFrame:FindFirstChild("Indicator")
                local isSelected = table.find(selectedValues, optionName) ~= nil
                if optionToggleIndicator then
                    if isSelected then
                        optionToggleIndicator.ImageRectOffset = Vector2.new(28, 4) -- Checked
                        optionToggleIndicator.ImageColor3 = Settings.Settings.UI.ToggleActiveColor
                    else
                        optionToggleIndicator.ImageRectOffset = Vector2.new(4, 4) -- Unchecked
                        optionToggleIndicator.ImageColor3 = Settings.Settings.UI.PrimaryText
                    end
                end
            end
        end
    end

    for _, option in ipairs(options) do
        local optionButton = create("TextButton", {
            Name = option .. "Option",
            BackgroundColor3 = Settings.Settings.UI.DropdownColor,
            BackgroundTransparency = 0.5,
            Size = UDim2.new(1, 0, 0, 20),
            Text = "",
            Font = Settings.Settings.UI.Font,
            TextColor3 = Settings.Settings.UI.PrimaryText,
            TextSize = 12,
            TextXAlignment = Enum.TextXAlignment.Left,
            Position = UDim2.new(0, 5, 0, 0),
            Parent = dropdownList
        })

        create("TextLabel", {
            Name = "Text",
            BackgroundTransparency = 1,
            Size = UDim2.new(1, -30, 1, 0),
            Position = UDim2.new(0, 5, 0, 0),
            Text = option,
            TextColor3 = Settings.Settings.UI.PrimaryText,
            TextSize = 12,
            Font = Settings.Settings.UI.Font,
            TextXAlignment = Enum.TextXAlignment.Left,
            Parent = optionButton
        })

        local optionToggleIndicator = create("ImageLabel", {
            Name = "Indicator",
            BackgroundTransparency = 1,
            Size = UDim2.new(0, 16, 0, 16),
            Position = UDim2.new(1, -20, 0.5, -8),
            Image = "rbxassetid://3926305904", -- Checkbox image asset
            ImageRectSize = Vector2.new(24, 24),
            Parent = optionButton
        })

        optionButton.MouseButton1Click:Connect(function()
            local index = table.find(selectedValues, option)
            if index then
                table.remove(selectedValues, index)
            else
                table.insert(selectedValues, option)
            end
            updateOptionState()
            updateSelectedText()
            if callback then callback(selectedValues) end
            showNotification(name, "Updated: " .. (index and "Removed " or "Added ") .. option, 1)
        end)
    end

    dropdownButton.MouseButton1Click:Connect(function()
        dropdownList.Visible = not dropdownList.Visible
    end)

    updateSelectedText()
    updateOptionState()
    return dropdownHolder, function() return selectedValues end, function(values) selectedValues = values updateOptionState() updateSelectedText() end
end

local function createColorPicker(parent, name, defaultValue, callback)
    local colorPickerHolder = create("Frame", {
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 25),
        Parent = parent
    })

    local colorButton = create("TextButton", {
        Name = "ColorButton",
        BackgroundColor3 = defaultValue,
        BorderColor3 = Settings.Settings.UI.BorderColor,
        BorderSizePixel = 1,
        Size = UDim2.new(0, 50, 0, 20),
        Position = UDim2.new(1, -50, 0.5, -10),
        Text = "",
        Parent = colorPickerHolder
    })

    create("TextLabel", {
        BackgroundTransparency = 1,
        Size = UDim2.new(1, -60, 1, 0),
        Position = UDim2.new(0, 5, 0, 0),
        Text = name,
        TextColor3 = Settings.Settings.UI.PrimaryText,
        TextSize = 12,
        Font = Settings.Settings.UI.Font,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = colorPickerHolder
    })

    local colorPickerFrame = create("Frame", {
        Name = "ColorPicker",
        BackgroundColor3 = Settings.Settings.UI.BackgroundColor,
        BorderColor3 = Settings.Settings.UI.ColorPickerBorder,
        BorderSizePixel = 1,
        Size = UDim2.new(0, 200, 0, 200),
        Position = UDim2.new(0.5, -100, 0.5, -100), -- Centered
        Visible = false,
        ZIndex = 3,
        Parent = screenGui -- Parent to screenGui to be on top
    })

    local saturationValueBox = create("Frame", {
        Name = "SaturationValueBox",
        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
        Size = UDim2.new(1, -20, 1, -20),
        Position = UDim2.new(0, 10, 0, 10),
        Parent = colorPickerFrame
    })

    local hueSlider = create("Frame", {
        Name = "HueSlider",
        BackgroundColor3 = Color3.fromRGB(255, 0, 0), -- Placeholder color
        Size = UDim2.new(0, 10, 1, -20),
        Position = UDim2.new(1, -15, 0, 10),
        Parent = colorPickerFrame
    })
    
    local gradient = create("UIGradient", {
        Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
            ColorSequenceKeypoint.new(0.166, Color3.fromRGB(255, 255, 0)),
            ColorSequenceKeypoint.new(0.333, Color3.fromRGB(0, 255, 0)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 255)),
            ColorSequenceKeypoint.new(0.666, Color3.fromRGB(0, 0, 255)),
            ColorSequenceKeypoint.new(0.833, Color3.fromRGB(255, 0, 255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0))
        }),
        Rotation = 90,
        Parent = hueSlider
    })

    local hueIndicator = create("Frame", {
        Name = "HueIndicator",
        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        BorderSizePixel = 1,
        Size = UDim2.new(1, 0, 0, 5),
        Position = UDim2.new(0, 0, 0, 0), -- Updated by logic
        ZIndex = 1,
        Parent = hueSlider
    })

    local alphaSlider = create("Frame", {
        Name = "AlphaSlider",
        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
        Size = UDim2.new(1, -20, 0, 10),
        Position = UDim2.new(0, 10, 1, -15),
        Parent = colorPickerFrame
    })

    local alphaGradient = create("UIGradient", {
        Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.new(0,0,0)), -- Transparent black
            ColorSequenceKeypoint.new(1, Color3.new(1,1,1))  -- Opaque white (will be updated)
        }),
        Parent = alphaSlider
    })

    local alphaIndicator = create("Frame", {
        Name = "AlphaIndicator",
        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
        BorderColor3 = Color3.fromRGB(0, 0, 0),
        BorderSizePixel = 1,
        Size = UDim2.new(0, 5, 1, 0),
        Position = UDim2.new(0, 0, 0, 0), -- Updated by logic
        ZIndex = 1,
        Parent = alphaSlider
    })

    local currentHue, currentSaturation, currentValue = RGBtoHSV(defaultValue)
    local currentAlpha = defaultValue.A

    local function updateColorVisuals()
        local rgbColor = HSVtoRGB(currentHue, currentSaturation, currentValue)
        colorButton.BackgroundColor3 = rgbColor

        saturationValueBox.BackgroundColor3 = HSVtoRGB(currentHue, 1, 1) -- Pure hue for saturation/value square
        
        local saturationOverlay = saturationValueBox:FindFirstChild("SaturationOverlay") or create("UIGradient", {
            Name = "SaturationOverlay",
            Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
                ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0))
            }),
            Rotation = 0,
            Parent = saturationValueBox
        })
        saturationOverlay.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.new(1,1,1)), -- White on left
            ColorSequenceKeypoint.new(1, Color3.new(0,0,0,0)) -- Transparent black on right
        })

        local valueOverlay = saturationValueBox:FindFirstChild("ValueOverlay") or create("UIGradient", {
            Name = "ValueOverlay",
            Color = ColorSequence.new({
                ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0, 0)),
                ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0))
            }),
            Rotation = 90,
            Parent = saturationValueBox
        })
        valueOverlay.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.new(0,0,0,0)), -- Transparent black on top
            ColorSequenceKeypoint.new(1, Color3.new(0,0,0))  -- Opaque black on bottom
        })

        hueIndicator.Position = UDim2.new(0, 0, currentHue, 0)
        alphaGradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.new(rgbColor.R, rgbColor.G, rgbColor.B, 0)),
            ColorSequenceKeypoint.new(1, Color3.new(rgbColor.R, rgbColor.G, rgbColor.B, 1))
        })
        alphaIndicator.Position = UDim2.new(currentAlpha, 0, 0, 0)
    end

    local svDragging = false
    saturationValueBox.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            svDragging = true
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and svDragging then
            local relativeX = math.max(0, math.min(1, (input.Position.X - saturationValueBox.AbsolutePosition.X) / saturationValueBox.AbsoluteSize.X))
            local relativeY = math.max(0, math.min(1, (input.Position.Y - saturationValueBox.AbsolutePosition.Y) / saturationValueBox.AbsoluteSize.Y))
            currentSaturation = relativeX
            currentValue = 1 - relativeY
            updateColorVisuals()
            if callback then callback(Color3.fromHSV(currentHue, currentSaturation, currentValue)) end
        end
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and svDragging then
            svDragging = false
            if callback then callback(Color3.fromHSV(currentHue, currentSaturation, currentValue)) end
        end
    end)

    local hueDragging = false
    hueSlider.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            hueDragging = true
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and hueDragging then
            local relativeY = math.max(0, math.min(1, (input.Position.Y - hueSlider.AbsolutePosition.Y) / hueSlider.AbsoluteSize.Y))
            currentHue = relativeY
            updateColorVisuals()
            if callback then callback(Color3.fromHSV(currentHue, currentSaturation, currentValue)) end
        end
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and hueDragging then
            hueDragging = false
            if callback then callback(Color3.fromHSV(currentHue, currentSaturation, currentValue)) end
        end
    end)

    local alphaDragging = false
    alphaSlider.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            alphaDragging = true
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and alphaDragging then
            local relativeX = math.max(0, math.min(1, (input.Position.X - alphaSlider.AbsolutePosition.X) / alphaSlider.AbsoluteSize.X))
            currentAlpha = relativeX
            updateColorVisuals()
            if callback then callback(Color3.fromHSV(currentHue, currentSaturation, currentValue, currentAlpha)) end
        end
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and alphaDragging then
            alphaDragging = false
            if callback then callback(Color3.fromHSV(currentHue, currentSaturation, currentValue, currentAlpha)) end
        end
    end)

    colorButton.MouseButton1Click:Connect(function()
        colorPickerFrame.Visible = not colorPickerFrame.Visible
    end)

    updateColorVisuals()
    return colorPickerHolder, function() return Color3.fromHSV(currentHue, currentSaturation, currentValue, currentAlpha) end, function(color) local h,s,v = RGBtoHSV(color) currentHue, currentSaturation, currentValue = h,s,v currentAlpha = color.A updateColorVisuals() end
end

local function createTextBox(parent, name, defaultValue, callback)
    local textBoxHolder = create("Frame", {
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 40),
        Parent = parent
    })

    local textBoxLabel = create("TextLabel", {
        BackgroundTransparency = 1,
        Size = UDim2.new(1, -70, 0, 15),
        Position = UDim2.new(0, 0, 0, 0),
        Font = Settings.Settings.UI.Font,
        Text = name,
        TextColor3 = Settings.Settings.UI.PrimaryText,
        TextSize = 12,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = textBoxHolder
    })

    local textBox = create("TextBox", {
        BackgroundColor3 = Settings.Settings.UI.TextBoxFillColor,
        BorderColor3 = Settings.Settings.UI.TextBoxOutlineColor,
        BorderSizePixel = 1,
        Size = UDim2.new(1, 0, 0, 18),
        Position = UDim2.new(0, 0, 0, 18),
        Text = defaultValue,
        Font = Settings.Settings.UI.Font,
        TextColor3 = Settings.Settings.UI.PrimaryText,
        TextSize = 12,
        TextXAlignment = Enum.TextXAlignment.Left,
        TextWrapped = true,
        ClearTextOnFocus = false,
        Parent = textBoxHolder
    })

    textBox.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            callback(textBox.Text)
            showNotification(name .. " Updated", "Value: " .. textBox.Text, 1)
        end
    end)
    return textBoxHolder, function() return textBox.Text end, function(value) textBox.Text = value end
end

-- Main GUI construction starts here
local screenGui = create("ScreenGui", {
    Name = "PupyywareGUI",
    DisplayOrder = 9999,
    ResetOnSpawn = false,
    ZIndexBehavior = "Global",
    Parent = CoreGui
})

-- NOTIFICATION SYSTEM SETUP (Smaller, Bottom-Middle, Improved Look)
local NotificationContainer = create("Frame", {
    Name = "NotificationContainer",
    BackgroundTransparency = 1,
    Size = UDim2.new(0, 300, 0, 0), -- Width 300, height set by AutomaticSize.Y
    Position = UDim2.new(0.5, -150, 1, -100), -- Bottom-middle, 100px from bottom
    LayoutOrder = 1,
    ClipsDescendants = true,
    Visible = Settings.ShowNotifications,
    Parent = screenGui
})

local NotificationListLayout = create("UIListLayout", {
    FillDirection = Enum.FillDirection.Vertical,
    HorizontalAlignment = Enum.HorizontalAlignment.Center,
    VerticalAlignment = Enum.VerticalAlignment.Bottom,
    Padding = UDim.new(0, 8), -- Increased padding
    Parent = NotificationContainer
})

-- Function to show notifications (limited for specific events)
local function showNotification(title, message, duration, customColor)
    if not Settings.ShowNotifications then return end

    local notificationFrame = create("Frame", {
        Name = "Notification",
        BackgroundColor3 = customColor or Settings.Settings.UI.NotificationColor,
        BackgroundTransparency = 0.9, -- Slightly transparent background
        BorderColor3 = Settings.Settings.UI.BorderColor,
        BorderSizePixel = 1,
        Size = UDim2.new(1, 0, 0, 60), -- Increased height
        AutomaticSize = Enum.AutomaticSize.Y,
        LayoutOrder = 0,
        Parent = NotificationContainer
    })

    -- Add UICorner for rounded corners
    create("UICorner", {
        CornerRadius = UDim.new(0, 8), -- Rounded corners
        Parent = notificationFrame
    })

    create("UIPadding", {
        PaddingTop = UDim.new(0, 8),
        PaddingBottom = UDim.new(0, 8),
        PaddingLeft = UDim.new(0, 15),
        PaddingRight = UDim.new(0, 15),
        Parent = notificationFrame
    })

    local notificationTitle = create("TextLabel", {
        Name = "Title",
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 20),
        Text = title,
        TextColor3 = Settings.Settings.UI.PrimaryText,
        TextSize = 16, -- Slightly larger title
        Font = Settings.Settings.UI.Font,
        TextXAlignment = Enum.TextXAlignment.Left,
        TextWrapped = true,
        Parent = notificationFrame
    })

    local notificationMessage = create("TextLabel", {
        Name = "Message",
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 20),
        Position = UDim2.new(0, 0, 0, 20),
        Text = message,
        TextColor3 = Settings.Settings.UI.SecondaryText,
        TextSize = 13, -- Slightly larger message
        Font = Settings.Settings.UI.Font,
        TextXAlignment = Enum.TextXAlignment.Left,
        TextWrapped = true,
        Parent = notificationFrame
    })

    -- Add a small visual line below the title for separation (optional but nice)
    create("Frame", {
        BackgroundColor3 = Settings.Settings.UI.AccentColor,
        Size = UDim2.new(1, 0, 0, 1),
        Position = UDim2.new(0, 0, 0, 22),
        Parent = notificationFrame
    })

    notificationFrame.BackgroundTransparency = 0.1 -- Set initial transparency
    notificationFrame:TweenPosition(UDim2.new(0.5, -notificationFrame.AbsoluteSize.X/2, 1, -notificationFrame.AbsoluteSize.Y - 10), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.3, true)

    coroutine.wrap(function()
        wait(duration or 3)
        notificationFrame:TweenPosition(UDim2.new(0.5, -notificationFrame.AbsoluteSize.X/2, 1, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quad, 0.3, true, function()
            notificationFrame:Destroy()
        end)
    end)()
end


-- WATERMARK SETUP (using GUI layout principles)
local WatermarkFrame = create("Frame", {
    Name = "Watermark",
    BackgroundTransparency = 1,
    Size = UDim2.new(0, 400, 0, 25), -- Increased width for text
    Position = UDim2.new(0, 10, 0, 10),
    Visible = Settings.ShowWatermark,
    Parent = screenGui
})

local WatermarkOutline = create("Frame", {
    BackgroundColor3 = Settings.Settings.UI.SurfaceColor,
    BorderColor3 = Settings.Settings.UI.BorderColor,
    BorderMode = "Inset",
    BorderSizePixel = 1,
    Size = UDim2.new(1, 0, 1, 0),
    Parent = WatermarkFrame
})

local WatermarkTextLabel = create("TextLabel", {
    Name = "WatermarkText",
    BackgroundTransparency = 1,
    Size = UDim2.new(1, -10, 1, -2), -- Small padding
    Position = UDim2.new(0, 5, 0, 1),
    Text = "",
    Font = Settings.Settings.UI.Font,
    TextColor3 = Settings.Settings.UI.WatermarkColor,
    TextSize = 14,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextStrokeTransparency = 0.8,
    Parent = WatermarkOutline
})

-- Watermark dynamic text and glitch effect
local watermarkState = "Normal" -- "Normal", "Discord", "Fuju"
local glitchActive = false
local glitchConnection = nil
local fujuLolColorTween = nil

local function updateWatermarkText()
    local fps = math.floor(1 / RunService.RenderStepped:Wait())
    local playerName = player.Name
    local text = Settings.WatermarkText:gsub("%[PLAYERNAME%]", playerName):gsub("%[FPS%]", tostring(fps))

    if watermarkState == "Discord" then
        WatermarkTextLabel.Text = "discord.gg/dawd"
        WatermarkTextLabel.TextColor3 = Settings.Settings.UI.WatermarkColor
    elseif watermarkState == "Fuju" then
        WatermarkTextLabel.Text = "fuju.lol"
        WatermarkTextLabel.TextColor3 = Settings.Settings.UI.WatermarkColor
        -- Special color for .lol
        if fujuLolColorTween then fujuLolColorTween:Cancel() end
        local richText = "<font color=\"" .. toHex(Settings.Settings.UI.WatermarkColor) .. "\">fuju</font><font color=\"" .. toHex(Settings.Settings.UI.WatermarkPinkColor) .. "\">.lol</font>"
        WatermarkTextLabel.RichText = true
        WatermarkTextLabel.Text = richText
    else
        WatermarkTextLabel.RichText = false
        WatermarkTextLabel.Text = text
        WatermarkTextLabel.TextColor3 = Settings.Settings.UI.WatermarkColor
    end
end

local function startWatermarkGlitchCycle()
    if glitchActive then return end
    glitchActive = true

    coroutine.wrap(function()
        while glitchActive do
            -- Glitch effect for 'Script FFA'
            local originalTitle = "Script FFA"
            local glitchedTitle = ""
            for i = 1, #originalTitle do
                if math.random() > 0.5 then
                    glitchedTitle = glitchedTitle .. string.char(math.random(33, 126)) -- Random ASCII char
                else
                    glitchedTitle = glitchedTitle .. string.sub(originalTitle, i, i)
                end
            end
            -- Assuming 'titleText' is a global or accessible variable for the main title
            -- If not, this part needs adjustment or removal
            -- titleText.Text = glitchedTitle .. " | Built-in Cheats" 
            wait(0.1)
            -- titleText.Text = originalTitle .. " | Built-in Cheats"
            wait(0.1)

            -- Cycle watermark text
            watermarkState = "Discord"
            updateWatermarkText()
            wait(3)

            watermarkState = "Fuju"
            updateWatermarkText()
            wait(30) -- Stay on fuju.lol for 30 seconds

            watermarkState = "Normal"
            updateWatermarkText()
            wait(5) -- Return to normal for 5 seconds
        end
    end)()
end

local function stopWatermarkGlitchCycle()
    glitchActive = false
    -- If titleText was used, reset it here
    -- titleText.Text = "Script FFA | Built-in Cheats" 
    watermarkState = "Normal"
    updateWatermarkText()
end

WatermarkFrame.Visible = Settings.ShowWatermark
if Settings.ShowWatermark then
    startWatermarkGlitchCycle()
else
    stopWatermarkGlitchCycle()
end

-- Listener for watermark settings
local watermarkToggleUpdater = nil
local function setupWatermarkUpdater()
    if watermarkToggleUpdater then watermarkToggleUpdater:Disconnect() end
    watermarkToggleUpdater = RunService.Stepped:Connect(function()
        if WatermarkFrame.Visible and Settings.ShowWatermark then
            -- Glitch cycle is handled by startWatermarkGlitchCycle
            updateWatermarkText()
        end
    end)
end
setupWatermarkUpdater()

local glowEffect = create("ImageLabel", {
    Name = "GlowEffect",
    AnchorPoint = Vector2.new(0.5, 0.5),
    BackgroundTransparency = 1,
    Position = UDim2.new(0.5, 0, 0.5, 0),
    Size = UDim2.new(0, 900, 0, 750),
    ZIndex = -1,
    Image = "rbxassetid://5028857084",
    ImageColor3 = Settings.Settings.UI.GlowColor,
    ImageTransparency = 1 - (Settings.Visuals.ESP.GlowIntensity / 100), -- Linked to a setting now
    Visible = Settings.GlowEnabled,
    Parent = screenGui
})

-- Main outline frame
local outline = create("Frame", {
    AnchorPoint = Vector2.new(0.5, 0.5),
    BackgroundColor3 = Settings.Settings.UI.AccentColor,
    BorderColor3 = Color3.fromRGB(12, 12, 12),
    BorderSizePixel = 1,
    Size = UDim2.new(0, 525, 0, 900), -- Updated size
    Position = UDim2.new(0.5, 0, 0.5, 0),
    ZIndex = 1,
    Parent = screenGui
})

-- Second outline (black border)
local outline2 = create("Frame", {
    AnchorPoint = Vector2.new(0.5, 0.5),
    BackgroundColor3 = Color3.fromRGB(0, 0, 0),
    BorderColor3 = Color3.fromRGB(12, 12, 12),
    BorderSizePixel = 1,
    Size = UDim2.new(1, -4, 1, -4),
    Position = UDim2.new(0.5, 0, 0.5, 0),
    Parent = outline
})

-- Inner frame
local indent = create("Frame", {
    AnchorPoint = Vector2.new(0.5, 0.5),
    BackgroundColor3 = Settings.Settings.UI.BackgroundColor,
    BorderColor3 = Settings.Settings.UI.BorderColor,
    BorderMode = "Inset",
    BorderSizePixel = 1,
    Size = UDim2.new(1, 0, 1, 0),
    Position = UDim2.new(0.5, 0, 0.5, 0),
    Parent = outline2
})

-- Main content area (This will be the tabs and sub-tabs)
local main = create("Frame", {
    Name = "MainContent",
    BackgroundTransparency = Settings.Settings.UI.BackgroundTransparency,
    Size = UDim2.new(1, -10, 1, -40), -- Adjusted for tabs and padding
    Position = UDim2.new(0, 5, 0, 35),
    Parent = indent
})

-- Tab buttons container
local tabButtonsContainer = create("Frame", {
    Name = "TabButtons",
    BackgroundTransparency = 1,
    Size = UDim2.new(1, 0, 0, 30),
    Position = UDim2.new(0, 0, 0, 0),
    Parent = indent
})

local tabListLayout = create("UIListLayout", {
    FillDirection = Enum.FillDirection.Horizontal,
    HorizontalAlignment = Enum.HorizontalAlignment.Left,
    Padding = UDim.new(0, 2),
    Parent = tabButtonsContainer
})

-- Tab content container (ScrollingFrame)
local tabContent = create("ScrollingFrame", {
    Name = "TabContent",
    BackgroundTransparency = Settings.Settings.UI.BackgroundTransparency,
    Size = UDim2.new(1, 0, 1, 0),
    Position = UDim2.new(0, 0, 0, 0),
    ZIndex = 1,
    CanvasSize = UDim2.new(0, 0, 0, 0), -- Will be updated by UIListLayout
    VerticalScrollBarInset = Enum.ScrollBarInset.Always,
    HorizontalScrollBarEndpoint = Enum.ScrollBarEndpoint.Always,
    Parent = main
})

local tabContentListLayout = create("UIListLayout", {
    FillDirection = Enum.FillDirection.Vertical,
    HorizontalAlignment = Enum.HorizontalAlignment.Center,
    Padding = UDim.new(0, 5),
    Parent = tabContent
})

tabContentListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    tabContent.CanvasSize = UDim2.new(0, 0, 0, tabContentListLayout.AbsoluteContentSize.Y)
end)


local tabPages = {}
local currentActiveTab = nil

local function createTab(name)
    local tabButton = create("TextButton", {
        Name = name .. "Tab",
        BackgroundColor3 = Settings.Settings.UI.TabInactiveColor,
        BorderColor3 = Settings.Settings.UI.BorderColor,
        BorderSizePixel = 1,
        Size = UDim2.new(0.25, -2, 1, 0), -- Roughly equal width for 4 tabs
        Text = name,
        TextColor3 = Settings.Settings.UI.PrimaryText,
        TextSize = 14,
        Font = Settings.Settings.UI.Font,
        Parent = tabButtonsContainer
    })

    local tabPage = create("ScrollingFrame", {
        Name = name .. "Page",
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 1, 0),
        CanvasSize = UDim2.new(0, 0, 0, 0), -- Will be updated by UIListLayout
        VerticalScrollBarInset = Enum.ScrollBarInset.Always,
        Active = true,
        Visible = false,
        Parent = tabContent
    })

    local pageLayout = create("UIListLayout", {
        FillDirection = Enum.FillDirection.Vertical,
        HorizontalAlignment = Enum.HorizontalAlignment.Center,
        Padding = UDim.new(0, 5),
        Parent = tabPage
    })

    pageLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        tabPage.CanvasSize = UDim2.new(0, 0, 0, pageLayout.AbsoluteContentSize.Y)
    end)

    tabPages[name] = {button = tabButton, page = tabPage}

    tabButton.MouseButton1Click:Connect(function()
        for _, tab in pairs(tabPages) do
            tab.page.Visible = false
            tab.button.BackgroundColor3 = Settings.Settings.UI.TabInactiveColor
        end
        tabPage.Visible = true
        tabButton.BackgroundColor3 = Settings.Settings.UI.TabActiveColor
        currentActiveTab = name
        showNotification("Tab Changed", "Switched to: " .. name, 0.8)
    end)

    return tabButton, tabPage
end

local function createSubTabs(parentFrame, subTabNames)
    local subTabContainer = create("Frame", {
        Name = "SubTabContainer",
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 25),
        Parent = parentFrame
    })

    local subTabListLayout = create("UIListLayout", {
        FillDirection = Enum.FillDirection.Horizontal,
        HorizontalAlignment = Enum.HorizontalAlignment.Left,
        Padding = UDim.new(0, 2),
        Parent = subTabContainer
    })

    local subTabContent = create("Frame", {
        Name = "SubTabContent",
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 1), -- Will expand with AutomaticSize.Y
        AutomaticSize = Enum.AutomaticSize.Y,
        Parent = parentFrame
    })

    local subTabPages = {}
    local currentActiveSubTab = nil

    for i, subTabName in ipairs(subTabNames) do
        local subTabButton = create("TextButton", {
            Name = subTabName .. "SubTab",
            BackgroundColor3 = Settings.Settings.UI.SubTabInactiveColor,
            BorderColor3 = Settings.Settings.UI.BorderColor,
            BorderSizePixel = 1,
            Size = UDim2.new(1 / #subTabNames, -((#subTabNames - 1) * 2) / #subTabNames, 1, 0), -- Distribute width
            Text = subTabName,
            TextColor3 = Settings.Settings.UI.PrimaryText,
            TextSize = 12,
            Font = Settings.Settings.UI.Font,
            Parent = subTabContainer
        })

        local subTabPage = create("ScrollingFrame", {
            Name = subTabName .. "SubTabPage",
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 1, 0),
            CanvasSize = UDim2.new(0, 0, 0, 0),
            VerticalScrollBarInset = Enum.ScrollBarInset.Always,
            Active = true,
            Visible = false,
            Parent = subTabContent
        })

        local subPageLayout = create("UIListLayout", {
            FillDirection = Enum.FillDirection.Vertical,
            HorizontalAlignment = Enum.HorizontalAlignment.Center,
            Padding = UDim.new(0, 5),
            Parent = subTabPage
        })

        subPageLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
            subTabPage.CanvasSize = UDim2.new(0, 0, 0, subPageLayout.AbsoluteContentSize.Y)
        end)

        subTabPages[subTabName] = {button = subTabButton, page = subTabPage}

        subTabButton.MouseButton1Click:Connect(function()
            for _, subTab in pairs(subTabPages) do
                subTab.page.Visible = false
                subTab.button.BackgroundColor3 = Settings.Settings.UI.SubTabInactiveColor
            end
            subTabPage.Visible = true
            subTabButton.BackgroundColor3 = Settings.Settings.UI.SubTabActiveColor
            currentActiveSubTab = subTabName
            showNotification("Sub-Tab Changed", "Switched to: " .. subTabName, 0.8)
        end)
    end

    -- Activate the first sub-tab by default
    if #subTabNames > 0 then
        subTabPages[subTabNames[1]].page.Visible = true
        subTabPages[subTabNames[1]].button.BackgroundColor3 = Settings.Settings.UI.SubTabActiveColor
        currentActiveSubTab = subTabNames[1]
    end

    return subTabPages, subTabContent -- Return pages and the content frame for layout
end

-- Create main tabs
local combatTabButton, combatTabPage = createTab("Combat")
local visualsTabButton, visualsTabPage = createTab("Visuals")
local miscTabButton, miscTabPage = createTab("Misc")
local settingsTabButton, settingsTabPage = createTab("Settings")

-- Activate the first tab by default
combatTabPage.Visible = true
combatTabButton.BackgroundColor3 = Settings.Settings.UI.TabActiveColor
currentActiveTab = "Combat"


-- Populate Tabs with UI Elements

-- Tab 1 - Combat
local combatSubTabs, combatSubTabContent = createSubTabs(combatTabPage, {"Aimbot", "Other", "Fun"})

-- Subtab 1 - Aimbot
local aimbotPage = combatSubTabs["Aimbot"].page

-- Section 1 - General
local aimbotGeneralSection = createSection(aimbotPage, "General")
local aimbotEnableToggle, _, _, getAimbotHotkey, setAimbotHotkey = createToggleWithHotkey(aimbotGeneralSection, "Enable Toggle", Settings.Combat.Enable, Settings.Combat.Hotkey, function(value, hotkey) Settings.Combat.Enable = value Settings.Combat.Hotkey = hotkey end)
local useChecksToggle, getUseChecks = createToggle(aimbotGeneralSection, "Use Checks", Settings.Combat.UseChecks, function(value) Settings.Combat.UseChecks = value end)
local checksDropdown, getChecksSelected, setChecksSelected = createMultiSelectDropdown(aimbotGeneralSection, "Checks", {"Team Check", "Wall Check", "Target Friends"}, {Settings.Combat.Checks.TeamCheck and "Team Check" or nil, Settings.Combat.Checks.WallCheck and "Wall Check" or nil, Settings.Combat.Checks.TargetFriends and "Target Friends" or nil}, function(values)
    Settings.Combat.Checks.TeamCheck = table.find(values, "Team Check") ~= nil
    Settings.Combat.Checks.WallCheck = table.find(values, "Wall Check") ~= nil
    Settings.Combat.Checks.TargetFriends = table.find(values, "Target Friends") ~= nil
end)
local useSmoothnessToggle, getUseSmoothness = createToggle(aimbotGeneralSection, "Use Smoothness", Settings.Combat.UseSmoothness, function(value) Settings.Combat.UseSmoothness = value end)
local usePredictionToggle, getUsePrediction = createToggle(aimbotGeneralSection, "Use Prediction", Settings.Combat.UsePrediction, function(value) Settings.Combat.UsePrediction = value end)
local useCustomOffsetToggle, getUseCustomOffset = createToggle(aimbotGeneralSection, "Use Custom Offset", Settings.Combat.UseCustomOffset, function(value) Settings.Combat.UseCustomOffset = value end)
local hitPartDropdown, getHitPart, setHitPart = createDropdown(aimbotGeneralSection, "Hit Part", PART_NAMES, Settings.Combat.HitPart, function(value) Settings.Combat.HitPart = value end)
local aimTypeDropdown, getAimType, setAimType = createDropdown(aimbotGeneralSection, "Aim Type", {"Mouse", "Camera"}, Settings.Combat.AimType, function(value) Settings.Combat.AimType = value end)

-- Section 2 - Settings
local aimbotSettingsSection = createSection(aimbotPage, "Settings")
local xSmoothnessSlider, getXSmoothness = createSlider(aimbotSettingsSection, "X Smoothness", 0, 100, Settings.Combat.XSmoothnessAmount, 1, function(value) Settings.Combat.XSmoothnessAmount = value end)
local ySmoothnessSlider, getYSmoothness = createSlider(aimbotSettingsSection, "Y Smoothness", 0, 100, Settings.Combat.YSmoothnessAmount, 1, function(value) Settings.Combat.YSmoothnessAmount = value end)
local xPredictionSlider, getXPrediction = createSlider(aimbotSettingsSection, "X Prediction", 0, 1, Settings.Combat.XPredictionAmount, 0.01, function(value) Settings.Combat.XPredictionAmount = value end)
local yPredictionSlider, getYPrediction = createSlider(aimbotSettingsSection, "Y Prediction", 0, 1, Settings.Combat.YPredictionAmount, 0.01, function(value) Settings.Combat.YPredictionAmount = value end)
local xOffsetSlider, getXOffset = createSlider(aimbotSettingsSection, "X Offset", -50, 50, Settings.Combat.XOffset, 0.1, function(value) Settings.Combat.XOffset = value end)
local yOffsetSlider, getYOffset = createSlider(aimbotSettingsSection, "Y Offset", -50, 50, Settings.Combat.YOffset, 0.1, function(value) Settings.Combat.YOffset = value end)

-- Section 3 - Aimbot FOV
local aimbotFovSection = createSection(aimbotPage, "Aimbot FOV")
local useFovToggle, getUseFov = createToggle(aimbotFovSection, "Use FOV", Settings.Combat.FOV.UseFOV, function(value) Settings.Combat.FOV.UseFOV = value end)
local drawFovToggle, getDrawFov = createToggle(aimbotFovSection, "Draw FOV", Settings.Combat.FOV.DrawFOV, function(value) Settings.Combat.FOV.DrawFOV = value end)
local fovOutlineColorPicker, getFovOutlineColor = createColorPicker(aimbotFovSection, "FOV Outline Color", Theme.FOVOutlineColor, function(color) Theme.FOVOutlineColor = color end)
local fillFovToggle, getFillFov = createToggle(aimbotFovSection, "Fill FOV", Settings.Combat.FOV.FillFOV, function(value) Settings.Combat.FOV.FillFOV = value end)
local fovFillColorPicker, getFovFillColor = createColorPicker(aimbotFovSection, "FOV Fill Color", Theme.FOVFillColor, function(color) Theme.FOVFillColor = color end)
local fovSizeSlider, getFovSize = createSlider(aimbotFovSection, "FOV Size", 10, 500, Settings.Combat.FOV.FOVSize, 1, function(value) Settings.Combat.FOV.FOVSize = value end)
local fovTransparencyFillSlider, getFovTransparencyFill = createSlider(aimbotFovSection, "FOV Transparency (Fill)", 0, 1, Settings.Combat.FOV.FOVTransparencyFill, 0.01, function(value) Settings.Combat.FOV.FOVTransparencyFill = value end)
local fovTransparencyOutlineSlider, getFovTransparencyOutline = createSlider(aimbotFovSection, "FOV Transparency (Outline)", 0, 1, Settings.Combat.FOV.FOVTransparencyOutline, 0.01, function(value) Settings.Combat.FOV.FOVTransparencyOutline = value end)

-- Subtab 2 - Other (Silent Aim, Orbit Lock)
local otherPage = combatSubTabs["Other"].page

-- Section 1 - Silent Aim
local silentAimSection = createSection(otherPage, "Silent Aim")
local silentAimEnableToggle, _, _, getSilentAimHotkey, setSilentAimHotkey = createToggleWithHotkey(silentAimSection, "Enable Toggle", Settings.Combat.SilentAim.Enable, Settings.Combat.SilentAim.Hotkey, function(value, hotkey) Settings.Combat.SilentAim.Enable = value Settings.Combat.SilentAim.Hotkey = hotkey end)
local silentHitPartDropdown, getSilentHitPart, setSilentHitPart = createMultiSelectDropdown(silentAimSection, "Hit Part", PART_NAMES, Settings.Combat.SilentAim.HitParts, function(values) Settings.Combat.SilentAim.HitParts = values end)
local hitChanceToggle, getHitChanceToggle = createToggle(silentAimSection, "Hit Chance", Settings.Combat.SilentAim.HitChanceToggle, function(value) Settings.Combat.SilentAim.HitChanceToggle = value end)
local hitChanceSlider, getHitChance = createSlider(silentAimSection, "Hit Chance", 0, 100, Settings.Combat.SilentAim.HitChance, 1, function(value) Settings.Combat.SilentAim.HitChance = value end)
hitChanceSlider.Visible = Settings.Combat.SilentAim.HitChanceToggle -- Initial visibility
getHitChanceToggle():GetPropertyChangedSignal("Value"):Connect(function() hitChanceSlider.Visible = getHitChanceToggle()() end) -- Update visibility

local silentWallCheckToggle, getSilentWallCheck = createToggle(silentAimSection, "Wall Check", Settings.Combat.SilentAim.WallCheck, function(value) Settings.Combat.SilentAim.WallCheck = value end)
local silentTeamCheckToggle, getSilentTeamCheck = createToggle(silentAimSection, "Team Check", Settings.Combat.SilentAim.TeamCheck, function(value) Settings.Combat.SilentAim.TeamCheck = value end)

-- Section 2 - Orbit Lock
local orbitLockSection = createSection(otherPage, "Orbit Lock")
local orbitLockEnableToggle, _, _, getOrbitLockHotkey, setOrbitLockHotkey = createToggleWithHotkey(orbitLockSection, "Enable Toggle", Settings.Combat.OrbitLock.Enable, Settings.Combat.OrbitLock.Hotkey, function(value, hotkey) Settings.Combat.OrbitLock.Enable = value Settings.Combat.OrbitLock.Hotkey = hotkey end)
local orbitHitPartDropdown, getOrbitHitPart, setOrbitHitPart = createDropdown(orbitLockSection, "Hit Part", PART_NAMES, Settings.Combat.OrbitLock.HitPart, function(value) Settings.Combat.OrbitLock.HitPart = value end)
local lookAtToggle, getLookAt = createToggle(orbitLockSection, "Look At", Settings.Combat.OrbitLock.LookAtTarget, function(value) Settings.Combat.OrbitLock.LookAtTarget = value end)
local spectateToggle, getSpectate = createToggle(orbitLockSection, "Spectate", Settings.Combat.OrbitLock.Spectate, function(value) Settings.Combat.OrbitLock.Spectate = value end)
local orbitPlacementDropdown, getOrbitPlacement, setOrbitPlacement = createDropdown(orbitLockSection, "Orbit Placement", {"Default", "Top", "Bottom", "Left", "Right"}, Settings.Combat.OrbitLock.OrbitPlacement, function(value) Settings.Combat.OrbitLock.OrbitPlacement = value end)
local orbitXOffsetSlider, getOrbitXOffset = createSlider(orbitLockSection, "X Orbit Offset", -50, 50, Settings.Combat.OrbitLock.XOffset, 0.1, function(value) Settings.Combat.OrbitLock.XOffset = value end)
local orbitYOffsetSlider, getOrbitYOffset = createSlider(orbitLockSection, "Y Orbit Offset", -50, 50, Settings.Combat.OrbitLock.YOffset, 0.1, function(value) Settings.Combat.OrbitLock.YOffset = value end)
local resetOffsetToggle, getResetOffset = createToggle(orbitLockSection, "Reset Offset", Settings.Combat.OrbitLock.ResetOffset, function(value) Settings.Combat.OrbitLock.ResetOffset = value if value then Settings.Combat.OrbitLock.XOffset = 0 Settings.Combat.OrbitLock.YOffset = 0 end end)

-- Section 3 - Silent Aim FOV
local silentAimFovSection = createSection(otherPage, "Silent Aim FOV")
local silentUseFovToggle, getSilentUseFov = createToggle(silentAimFovSection, "Use FOV", Settings.Combat.SilentAim.FOV.UseFOV, function(value) Settings.Combat.SilentAim.FOV.UseFOV = value end)
local silentDrawFovToggle, getSilentDrawFov = createToggle(silentAimFovSection, "Draw FOV", Settings.Combat.SilentAim.FOV.DrawFOV, function(value) Settings.Combat.SilentAim.FOV.DrawFOV = value end)
local silentFovOutlineColorPicker, getSilentFovOutlineColor = createColorPicker(silentAimFovSection, "FOV Outline Color", Theme.SilentFOVOutlineColor, function(color) Theme.SilentFOVOutlineColor = color end)
local silentFillFovToggle, getSilentFillFov = createToggle(silentAimFovSection, "Fill FOV", Settings.Combat.SilentAim.FOV.FillFOV, function(value) Settings.Combat.SilentAim.FOV.FillFOV = value end)
local silentFovFillColorPicker, getSilentFovFillColor = createColorPicker(silentAimFovSection, "FOV Fill Color", Theme.SilentFOVFillColor, function(color) Theme.SilentFOVFillColor = color end)
local silentFovSizeSlider, getSilentFovSize = createSlider(silentAimFovSection, "FOV Size", 10, 500, Settings.Combat.SilentAim.FOV.FOVSize, 1, function(value) Settings.Combat.SilentAim.FOV.FOVSize = value end)
local silentFovTransparencyFillSlider, getSilentFovTransparencyFill = createSlider(silentAimFovSection, "FOV Transparency (Fill)", 0, 1, Settings.Combat.SilentAim.FOV.FOVTransparencyFill, 0.01, function(value) Settings.Combat.SilentAim.FOV.FOVTransparencyFill = value end)
local silentFovTransparencyOutlineSlider, getSilentFovTransparencyOutline = createSlider(silentAimFovSection, "FOV Transparency (Outline)", 0, 1, Settings.Combat.SilentAim.FOV.FOVTransparencyOutline, 0.01, function(value) Settings.Combat.SilentAim.FOV.FOVTransparencyOutline = value end)

-- Subtab 3 - Fun
local funPage = combatSubTabs["Fun"].page

-- Section 1 - Fun 1 (More Soon)
local funSection = createSection(funPage, "Fun 1 (More Soon)")
create("TextLabel", { BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 20), Text = "(Also this is for Silent Aim, Aimbot, Orbit Lock)", TextColor3 = Settings.Settings.UI.SecondaryText, TextSize = 10, Font = Settings.Settings.UI.Font, TextXAlignment = Enum.TextXAlignment.Left, Parent = funSection })
local hitNotificationToggle, getHitNotification = createToggle(funSection, "Hit Notification", Settings.Combat.HitNotification, function(value) Settings.Combat.HitNotification = value end)
local hitSoundDropdown, getHitSound = createDropdown(funSection, "Hit Sound", {"None", "Rust", "Neverlose", "MW2019", "Coin1", "Coin2", "RustHeadshot", "Ding"}, Settings.Combat.HitSound, function(value) Settings.Combat.HitSound = value end)
local targetTracerToggle, getTargetTracer = createToggle(funSection, "Target Tracer", Settings.Combat.TargetTracer, function(value) Settings.Combat.TargetTracer = value end)
local targetTracerColorPicker, getTargetTracerColor = createColorPicker(funSection, "Target Tracer Color", Theme.TargetTracerColor, function(color) Theme.TargetTracerColor = color end)
local targetHeadDotToggle, getTargetHeadDot = createToggle(funSection, "Target Head Dot", Settings.Combat.TargetHeadDot, function(value) Settings.Combat.TargetHeadDot = value end)
local targetHeadDotColorPicker, getTargetHeadDotColor = createColorPicker(funSection, "Target Head Dot Color", Theme.TargetHeadDotColor, function(color) Theme.TargetHeadDotColor = color end)
local targetInfoBoxToggle, getTargetInfoBox = createToggle(funSection, "Target Info Box", Settings.Combat.TargetInfoBox, function(value) Settings.Combat.TargetInfoBox = value end)
local targetInfoBoxColorPicker, getTargetInfoBoxColor = createColorPicker(funSection, "Target Info Box Color", Theme.TargetInfoBoxColor, function(color) Theme.TargetInfoBoxColor = color end)
local targetGlowChamsToggle, getTargetGlowChams = createToggle(funSection, "Target Glow Chams", Settings.Combat.TargetGlowChams, function(value) Settings.Combat.TargetGlowChams = value end)
local targetGlowChamsColorPicker, getTargetGlowChamsColor = createColorPicker(funSection, "Target Glow Chams Color", Theme.TargetGlowChamsColor, function(color) Theme.TargetGlowChamsColor = color end)


-- Tab 2 - Visuals
local visualsSubTabs, visualsSubTabContent = createSubTabs(visualsTabPage, {"ESP", "World"})

-- Subtab 1 - ESP
local espPage = visualsSubTabs["ESP"].page

-- Section 1 - ESP
local espSection = createSection(espPage, "ESP")
local espEnableToggle, getEspEnable = createToggle(espSection, "Enable", Settings.Visuals.ESP.Enable, function(value) Settings.Visuals.ESP.Enable = value end)
local boxEspToggle, getBoxEsp = createToggle(espSection, "Box ESP", Settings.Visuals.ESP.BoxESP, function(value) Settings.Visuals.ESP.BoxESP = value end)
local boxEspColorPicker, getBoxEspColor = createColorPicker(espSection, "Box ESP Color", Theme.ESPBoxColor, function(color) Theme.ESPBoxColor = color end)
local boxTypeDropdown, getBoxType = createDropdown(espSection, "Box Type", {"Normal", "Corner", "3D"}, Settings.Visuals.ESP.BoxType, function(value) Settings.Visuals.ESP.BoxType = value end)
local boxGlowEspToggle, getBoxGlowEsp = createToggle(espSection, "Box Glow ESP", Settings.Visuals.ESP.BoxGlow, function(value) Settings.Visuals.ESP.BoxGlow = value end)
local boxGlowEspColorPicker, getBoxGlowEspColor = createColorPicker(espSection, "Box Glow ESP Color", Theme.ESPBoxGlowColor, function(color) Theme.ESPBoxGlowColor = color end)
local nameEspToggle, getNameEsp = createToggle(espSection, "Name ESP", Settings.Visuals.ESP.NameESP, function(value) Settings.Visuals.ESP.NameESP = value end)
local nameEspColorPicker, getNameEspColor = createColorPicker(espSection, "Name ESP Color", Theme.ESPNameColor, function(color) Theme.ESPNameColor = color end)
local textOutlineToggle, getTextOutline = createToggle(espSection, "Text Outline", Settings.Visuals.ESP.NameOutline, function(value) Settings.Visuals.ESP.NameOutline = value end)
local textOutlineColorPicker, getTextOutlineColor = createColorPicker(espSection, "Text Outline Color", Theme.ESPNameOutlineColor, function(color) Theme.ESPNameOutlineColor = color end)
local nameEspGlowToggle, getNameEspGlow = createToggle(espSection, "Name ESP Glow", Settings.Visuals.ESP.NameGlow, function(value) Settings.Visuals.ESP.NameGlow = value end)
local nameEspGlowColorPicker, getNameEspGlowColor = createColorPicker(espSection, "Name ESP Glow Color", Theme.ESPNameGlowColor, function(color) Theme.ESPNameGlowColor = color end)
local healthBarEspToggle, getHealthBarEsp = createToggle(espSection, "Health Bar ESP", Settings.Visuals.ESP.HealthBarESP, function(value) Settings.Visuals.ESP.HealthBarESP = value end)
local healthBarEspColorPickerBG, getHealthBarEspColorBG = createColorPicker(espSection, "Health Bar BG Color", Theme.ESPHealthBarBGColor, function(color) Theme.ESPHealthBarBGColor = color end)
local healthBarEspColorPickerHealth, getHealthBarEspColorHealth = createColorPicker(espSection, "Health Bar Color", Theme.ESPHealthBarColor, function(color) Theme.ESPHealthBarColor = color end)
local healthBarEspOutlineToggle, getHealthBarEspOutline = createToggle(espSection, "Health Bar Outline", Settings.Visuals.ESP.HealthBarOutline, function(value) Settings.Visuals.ESP.HealthBarOutline = value end)
local healthBarEspOutlineColorPicker, getHealthBarEspOutlineColor = createColorPicker(espSection, "Health Bar Outline Color", Theme.ESPHealthBarOutlineColor, function(color) Theme.ESPHealthBarOutlineColor = color end)
local healthBarEspGlowToggle, getHealthBarEspGlow = createToggle(espSection, "Health Bar Glow", Settings.Visuals.ESP.HealthBarGlow, function(value) Settings.Visuals.ESP.HealthBarGlow = value end)
local healthBarEspGlowColorPicker, getHealthBarEspGlowColor = createColorPicker(espSection, "Health Bar Glow Color", Theme.ESPHealthBarGlowColor, function(color) Theme.ESPHealthBarGlowColor = color end)
local toolEspToggle, getToolEsp = createToggle(espSection, "Tool ESP", Settings.Visuals.ESP.ToolESP, function(value) Settings.Visuals.ESP.ToolESP = value end)
local toolEspColorPicker, getToolEspColor = createColorPicker(espSection, "Tool ESP Color", Theme.ESPToolColor, function(color) Theme.ESPToolColor = color end)
local toolTextOutlineToggle, getToolTextOutline = createToggle(espSection, "Tool Text Outline", Settings.Visuals.ESP.ToolOutline, function(value) Settings.Visuals.ESP.ToolOutline = value end)
local toolTextOutlineColorPicker, getToolTextOutlineColor = createColorPicker(espSection, "Tool Text Outline Color", Theme.ESPToolOutlineColor, function(color) Theme.ESPToolOutlineColor = color end)
local toolEspGlowToggle, getToolEspGlow = createToggle(espSection, "Tool ESP Glow", Settings.Visuals.ESP.ToolGlow, function(value) Settings.Visuals.ESP.ToolGlow = value end)
local toolEspGlowColorPicker, getToolEspGlowColor = createColorPicker(espSection, "Tool ESP Glow Color", Theme.ESPToolGlowColor, function(color) Theme.ESPToolGlowColor = color end)
local distanceEspToggle, getDistanceEsp = createToggle(espSection, "Distance ESP", Settings.Visuals.ESP.DistanceESP, function(value) Settings.Visuals.ESP.DistanceESP = value end)
local distanceEspColorPicker, getDistanceEspColor = createColorPicker(espSection, "Distance ESP Color", Theme.ESPDistanceColor, function(color) Theme.ESPDistanceColor = color end)
local distanceTextOutlineToggle, getDistanceTextOutline = createToggle(espSection, "Distance Text Outline", Settings.Visuals.ESP.DistanceOutline, function(value) Settings.Visuals.ESP.DistanceOutline = value end)
local distanceTextOutlineColorPicker, getDistanceTextOutlineColor = createColorPicker(espSection, "Distance Text Outline Color", Theme.ESPDistanceOutlineColor, function(color) Theme.ESPDistanceOutlineColor = color end)
local distanceEspGlowToggle, getDistanceEspGlow = createToggle(espSection, "Distance ESP Glow", Settings.Visuals.ESP.DistanceGlow, function(value) Settings.Visuals.ESP.DistanceGlow = value end)
local distanceEspGlowColorPicker, getDistanceEspGlowColor = createColorPicker(espSection, "Distance ESP Glow Color", Theme.ESPDistanceGlowColor, function(color) Theme.ESPDistanceGlowColor = color end)
local chamsEspToggle, getChamsEsp = createToggle(espSection, "Chams ESP", Settings.Visuals.ESP.ChamsESP, function(value) Settings.Visuals.ESP.ChamsESP = value end)
local chamsEspColorPicker, getChamsEspColor = createColorPicker(espSection, "Chams ESP Color", Theme.ESPChamsColor, function(color) Theme.ESPChamsColor = color end)
local chamsGlowToggle, getChamsGlow = createToggle(espSection, "Chams Glow", Settings.Visuals.ESP.ChamsGlow, function(value) Settings.Visuals.ESP.ChamsGlow = value end)
local chamsGlowColorPicker, getChamsGlowColor = createColorPicker(espSection, "Chams Glow Color", Theme.ESPChamsGlowColor, function(color) Theme.ESPChamsGlowColor = color end)
local skeletonEspToggle, getSkeletonEsp = createToggle(espSection, "Skeleton ESP", Settings.Visuals.ESP.SkeletonESP, function(value) Settings.Visuals.ESP.SkeletonESP = value end)
local skeletonEspColorPicker, getSkeletonEspColor = createColorPicker(espSection, "Skeleton ESP Color", Theme.ESPSkeletonColor, function(color) Theme.ESPSkeletonColor = color end)
local skeletonGlowToggle, getSkeletonGlow = createToggle(espSection, "Skeleton Glow", Settings.Visuals.ESP.SkeletonGlow, function(value) Settings.Visuals.ESP.SkeletonGlow = value end)
local skeletonGlowColorPicker, getSkeletonGlowColor = createColorPicker(espSection, "Skeleton Glow Color", Theme.ESPSkeletonGlowColor, function(color) Theme.ESPSkeletonGlowColor = color end)

-- Mini Section Below - Other
local espOtherSection = createSection(espSection, "Other", 100)
local glowIntensitySlider, getGlowIntensity = createSlider(espOtherSection, "Glow Intensity", 0, 100, Settings.Visuals.ESP.GlowIntensity, 1, function(value) Settings.Visuals.ESP.GlowIntensity = value glowEffect.ImageTransparency = 1 - (value / 100) end)
local espDistanceSlider, getEspDistance = createSlider(espOtherSection, "ESP Distance", 50, 2000, Settings.Visuals.ESP.Distance, 10, function(value) Settings.Visuals.ESP.Distance = value end)
local healthBarNumberToggle, getHealthBarNumber = createToggle(espOtherSection, "Health Bar Number", Settings.Visuals.ESP.HealthNumber, function(value) Settings.Visuals.ESP.HealthNumber = value end)
local healthBarNumberColorPicker, getHealthBarNumberColor = createColorPicker(espOtherSection, "Health Bar Number Color", Theme.ESPHealthNumberColor, function(color) Theme.ESPHealthNumberColor = color end)

-- Section 2 - Self ESP
local selfEspSection = createSection(espPage, "Self ESP")
local selfEspEnableToggle, getSelfEspEnable = createToggle(selfEspSection, "Enable", Settings.Visuals.SelfESP.Enable, function(value) Settings.Visuals.SelfESP.Enable = value end)
local selfBoxEspToggle, getSelfBoxEsp = createToggle(selfEspSection, "Box ESP", Settings.Visuals.SelfESP.BoxESP, function(value) Settings.Visuals.SelfESP.BoxESP = value end)
local selfBoxEspColorPicker, getSelfBoxEspColor = createColorPicker(selfEspSection, "Box ESP Color", Theme.SelfESPBoxColor, function(color) Theme.SelfESPBoxColor = color end)
local selfBoxTypeDropdown, getSelfBoxType = createDropdown(selfEspSection, "Box Type", {"Normal", "Corner", "3D"}, Settings.Visuals.SelfESP.BoxType, function(value) Settings.Visuals.SelfESP.BoxType = value end)
local selfBoxGlowEspToggle, getSelfBoxGlowEsp = createToggle(selfEspSection, "Box Glow ESP", Settings.Visuals.SelfESP.BoxGlow, function(value) Settings.Visuals.SelfESP.BoxGlow = value end)
local selfBoxGlowEspColorPicker, getSelfBoxGlowEspColor = createColorPicker(selfEspSection, "Box Glow ESP Color", Theme.SelfESPBoxGlowColor, function(color) Theme.SelfESPBoxGlowColor = color end)
local selfNameEspToggle, getSelfNameEsp = createToggle(selfEspSection, "Name ESP", Settings.Visuals.SelfESP.NameESP, function(value) Settings.Visuals.SelfESP.NameESP = value end)
local selfNameEspColorPicker, getSelfNameEspColor = createColorPicker(selfEspSection, "Name ESP Color", Theme.SelfESPNameColor, function(color) Theme.SelfESPNameColor = color end)
local selfTextOutlineToggle, getSelfTextOutline = createToggle(selfEspSection, "Text Outline", Settings.Visuals.SelfESP.NameOutline, function(value) Settings.Visuals.SelfESP.NameOutline = value end)
local selfTextOutlineColorPicker, getSelfTextOutlineColor = createColorPicker(selfEspSection, "Text Outline Color", Theme.SelfESPNameOutlineColor, function(color) Theme.SelfESPNameOutlineColor = color end)
local selfNameEspGlowToggle, getSelfNameEspGlow = createToggle(selfEspSection, "Name ESP Glow", Settings.Visuals.SelfESP.NameGlow, function(value) Settings.Visuals.SelfESP.NameGlow = value end)
local selfNameEspGlowColorPicker, getSelfNameEspGlowColor = createColorPicker(selfEspSection, "Name ESP Glow Color", Theme.SelfESPNameGlowColor, function(color) Theme.SelfESPNameGlowColor = color end)
local selfHealthBarEspToggle, getSelfHealthBarEsp = createToggle(selfEspSection, "Health Bar ESP", Settings.Visuals.SelfESP.HealthBarESP, function(value) Settings.Visuals.SelfESP.HealthBarESP = value end)
local selfHealthBarEspColorPickerBG, getSelfHealthBarEspColorBG = createColorPicker(selfEspSection, "Health Bar BG Color", Theme.SelfESPHealthBarBGColor, function(color) Theme.SelfESPHealthBarBGColor = color end)
local selfHealthBarEspColorPickerHealth, getSelfHealthBarEspColorHealth = createColorPicker(selfEspSection, "Health Bar Color", Theme.SelfESPHealthBarColor, function(color) Theme.SelfESPHealthBarColor = color end)
local selfHealthBarEspOutlineToggle, getSelfHealthBarEspOutline = createToggle(selfEspSection, "Health Bar Outline", Settings.Visuals.SelfESP.HealthBarOutline, function(value) Settings.Visuals.SelfESP.HealthBarOutline = value end)
local selfHealthBarEspOutlineColorPicker, getSelfHealthBarEspOutlineColor = createColorPicker(selfEspSection, "Health Bar Outline Color", Theme.SelfESPHealthBarOutlineColor, function(color) Theme.SelfESPHealthBarOutlineColor = color end)
local selfHealthBarEspGlowToggle, getSelfHealthBarEspGlow = createToggle(selfEspSection, "Health Bar Glow", Settings.Visuals.SelfESP.HealthBarGlow, function(value) Settings.Visuals.SelfESP.HealthBarGlow = value end)
local selfHealthBarEspGlowColorPicker, getSelfHealthBarEspGlowColor = createColorPicker(selfEspSection, "Health Bar Glow Color", Theme.SelfESPHealthBarGlowColor, function(color) Theme.SelfESPHealthBarGlowColor = color end)
local selfToolEspToggle, getSelfToolEsp = createToggle(selfEspSection, "Tool ESP", Settings.Visuals.SelfESP.ToolESP, function(value) Settings.Visuals.SelfESP.ToolESP = value end)
local selfToolEspColorPicker, getSelfToolEspColor = createColorPicker(selfEspSection, "Tool ESP Color", Theme.SelfESPToolColor, function(color) Theme.SelfESPToolColor = color end)
local selfToolTextOutlineToggle, getSelfToolTextOutline = createToggle(selfEspSection, "Tool Text Outline", Settings.Visuals.SelfESP.ToolOutline, function(value) Settings.Visuals.SelfESP.ToolOutline = value end)
local selfToolTextOutlineColorPicker, getSelfToolTextOutlineColor = createColorPicker(selfEspSection, "Tool Text Outline Color", Theme.SelfESPToolOutlineColor, function(color) Theme.SelfESPToolOutlineColor = color end)
local selfToolEspGlowToggle, getSelfToolEspGlow = createToggle(selfEspSection, "Tool ESP Glow", Settings.Visuals.SelfESP.ToolGlow, function(value) Settings.Visuals.SelfESP.ToolGlow = value end)
local selfToolEspGlowColorPicker, getSelfToolEspGlowColor = createColorPicker(selfEspSection, "Tool ESP Glow Color", Theme.SelfESPToolGlowColor, function(color) Theme.SelfESPToolGlowColor = color end)
local selfDistanceEspToggle, getSelfDistanceEsp = createToggle(selfEspSection, "Distance ESP", Settings.Visuals.SelfESP.DistanceESP, function(value) Settings.Visuals.SelfESP.DistanceESP = value end)
local selfDistanceEspColorPicker, getSelfDistanceEspColor = createColorPicker(selfEspSection, "Distance ESP Color", Theme.SelfESPDistanceColor, function(color) Theme.SelfESPDistanceColor = color end)
local selfDistanceTextOutlineToggle, getSelfDistanceTextOutline = createToggle(selfEspSection, "Distance Text Outline", Settings.Visuals.SelfESP.DistanceOutline, function(value) Settings.Visuals.SelfESP.DistanceOutline = value end)
local selfDistanceTextOutlineColorPicker, getSelfDistanceTextOutlineColor = createColorPicker(selfEspSection, "Distance Text Outline Color", Theme.SelfESPDistanceOutlineColor, function(color) Theme.SelfESPDistanceOutlineColor = color end)
local selfDistanceEspGlowToggle, getSelfDistanceEspGlow = createToggle(selfEspSection, "Distance ESP Glow", Settings.Visuals.SelfESP.DistanceGlow, function(value) Settings.Visuals.SelfESP.DistanceGlow = value end)
local selfDistanceEspGlowColorPicker, getSelfDistanceEspGlowColor = createColorPicker(selfEspSection, "Distance ESP Glow Color", Theme.SelfESPDistanceGlowColor, function(color) Theme.SelfESPDistanceGlowColor = color end)
local selfChamsEspToggle, getSelfChamsEsp = createToggle(selfEspSection, "Chams ESP", Settings.Visuals.SelfESP.ChamsESP, function(value) Settings.Visuals.SelfESP.ChamsESP = value end)
local selfChamsEspColorPicker, getSelfChamsEspColor = createColorPicker(selfEspSection, "Chams ESP Color", Theme.SelfESPChamsColor, function(color) Theme.SelfESPChamsColor = color end)
local selfChamsGlowToggle, getSelfChamsGlow = createToggle(selfEspSection, "Chams Glow", Settings.Visuals.SelfESP.ChamsGlow, function(value) Settings.Visuals.SelfESP.ChamsGlow = value end)
local selfChamsGlowColorPicker, getSelfChamsGlowColor = createColorPicker(selfEspSection, "Chams Glow Color", Theme.SelfESPChamsGlowColor, function(color) Theme.SelfESPChamsGlowColor = color end)

-- Mini Section Below - Other (Self ESP)
local selfEspOtherSection = createSection(selfEspSection, "Other", 100)
local selfGlowIntensitySlider, getSelfGlowIntensity = createSlider(selfEspOtherSection, "Glow Intensity", 0, 100, Settings.Visuals.SelfESP.GlowIntensity, 1, function(value) Settings.Visuals.SelfESP.GlowIntensity = value end)
local selfEspDistanceSlider, getSelfEspDistance = createSlider(selfEspOtherSection, "ESP Distance", 50, 2000, Settings.Visuals.SelfESP.Distance, 10, function(value) Settings.Visuals.SelfESP.Distance = value end)
local selfHealthBarNumberToggle, getSelfHealthBarNumber = createToggle(selfEspOtherSection, "Health Bar Number", Settings.Visuals.SelfESP.HealthNumber, function(value) Settings.Visuals.SelfESP.HealthNumber = value end)
local selfHealthBarNumberColorPicker, getSelfHealthBarNumberColor = createColorPicker(selfEspOtherSection, "Health Bar Number Color", Theme.SelfESPHealthNumberColor, function(color) Theme.SelfESPHealthNumberColor = color end)


-- Subtab 2 - World
local worldPage = visualsSubTabs["World"].page

-- Section 1 - World 1
local world1Section = createSection(worldPage, "World 1")
local ambienceColorToggle, getAmbienceColorToggle = createToggle(world1Section, "Ambience Color", Settings.Visuals.World.AmbienceColorToggle, function(value) Settings.Visuals.World.AmbienceColorToggle = value end)
local ambienceColorPicker, getAmbienceColor = createColorPicker(world1Section, "Ambience Color", Theme.WorldAmbienceColor, function(color) Theme.WorldAmbienceColor = color Lighting.Ambient = color end)
local buildingColorToggle, getBuildingColorToggle = createToggle(world1Section, "Building Color", Settings.Visuals.World.BuildingColorToggle, function(value) Settings.Visuals.World.BuildingColorToggle = value end)
local buildingColorPicker, getBuildingColor = createColorPicker(world1Section, "Building Color", Theme.WorldBuildingColor, function(color) Theme.WorldBuildingColor = color Lighting.OutdoorAmbient = color end)
local fogColorToggle, getFogColorToggle = createToggle(world1Section, "Fog Color", Settings.Visuals.World.FogColorToggle, function(value) Settings.Visuals.World.FogColorToggle = value end)
local fogColorPicker, getFogColor = createColorPicker(world1Section, "Fog Color", Theme.WorldFogColor, function(color) Theme.WorldFogColor = color Lighting.FogColor = color end)
local fogEndSlider, getFogEnd = createSlider(world1Section, "Fog End", 0, 50000, Settings.Visuals.World.FogEnd, 100, function(value) Settings.Visuals.World.FogEnd = value Lighting.FogEnd = value end)
local fogStartSlider, getFogStart = createSlider(world1Section, "Fog Start", 0, 50000, Settings.Visuals.World.FogStart, 100, function(value) Settings.Visuals.World.FogStart = value Lighting.FogStart = value end)
local screenColorOverlayToggle, getScreenColorOverlayToggle = createToggle(world1Section, "Screen Color Overlay", Settings.Visuals.World.ScreenColorOverlayToggle, function(value) Settings.Visuals.World.ScreenColorOverlayToggle = value end)
local screenColorOverlayPicker, getScreenColorOverlay = createColorPicker(world1Section, "Screen Color Overlay Color", Theme.WorldScreenColor, function(color) Theme.WorldScreenColor = color end)

-- Mini Section Below - Other (World)
local worldOtherSection = createSection(world1Section, "Other", 100)
local ambienceColorGlowToggle, getAmbienceColorGlow = createToggle(worldOtherSection, "Ambience Color Glow", Settings.Visuals.World.AmbienceGlow, function(value) Settings.Visuals.World.AmbienceGlow = value end)
local ambienceColorGlowPicker, getAmbienceColorGlowColor = createColorPicker(worldOtherSection, "Ambience Glow Color", Theme.WorldAmbienceGlowColor, function(color) Theme.WorldAmbienceGlowColor = color end)
local buildingColorGlowToggle, getBuildingColorGlow = createToggle(worldOtherSection, "Building Color Glow", Settings.Visuals.World.BuildingGlow, function(value) Settings.Visuals.World.BuildingGlow = value end)
local buildingColorGlowPicker, getBuildingColorGlowColor = createColorPicker(worldOtherSection, "Building Glow Color", Theme.WorldBuildingGlowColor, function(color) Theme.WorldBuildingGlowColor = color end)
local fogColorGlowToggle, getFogColorGlow = createToggle(worldOtherSection, "Fog Color Glow", Settings.Visuals.World.FogGlow, function(value) Settings.Visuals.World.FogGlow = value end)
local fogColorGlowPicker, getFogColorGlowColor = createColorPicker(worldOtherSection, "Fog Glow Color", Theme.WorldFogGlowColor, function(color) Theme.WorldFogGlowColor = color end)

-- Section 2 - Effects
local effectsSection = createSection(worldPage, "Effects")
local snowFlakeEffectToggle, getSnowFlakeEffect = createToggle(effectsSection, "Snowflake Effect", Settings.Visuals.Effects.SnowFlakes, function(value) Settings.Visuals.Effects.SnowFlakes = value end)
local helloKittyEffectToggle, getHelloKittyEffect = createToggle(effectsSection, "Hello Kitty Effect", Settings.Visuals.Effects.HelloKitty, function(value) Settings.Visuals.Effects.HelloKitty = value end)
local selfBulletTracerToggle, getSelfBulletTracer = createToggle(effectsSection, "Self Bullet Tracer", Settings.Visuals.Effects.SelfBulletTracer, function(value) Settings.Visuals.Effects.SelfBulletTracer = value end)
local selfBulletTracerColorPicker, getSelfBulletTracerColor = createColorPicker(effectsSection, "Self Bullet Tracer Color", Theme.EffectSelfBulletTracerColor, function(color) Theme.EffectSelfBulletTracerColor = color end)
local enemyBulletTracerToggle, getEnemyBulletTracer = createToggle(effectsSection, "Enemy Bullet Tracer", Settings.Visuals.Effects.EnemyBulletTracer, function(value) Settings.Visuals.Effects.EnemyBulletTracer = value end)
local enemyBulletTracerColorPicker, getEnemyBulletTracerColor = createColorPicker(effectsSection, "Enemy Bullet Tracer Color", Theme.EffectEnemyBulletTracerColor, function(color) Theme.EffectEnemyBulletTracerColor = color end)
local bulletStartSlider, getBulletStart = createSlider(effectsSection, "Bullet Start Size", 0, 10, Settings.Visuals.Effects.BulletStartSize, 0.1, function(value) Settings.Visuals.Effects.BulletStartSize = value end)
local bulletEndSlider, getBulletEnd = createSlider(effectsSection, "Bullet End Size", 0, 10, Settings.Visuals.Effects.BulletEndSize, 0.1, function(value) Settings.Visuals.Effects.BulletEndSize = value end)
local bulletDurationSlider, getBulletDuration = createSlider(effectsSection, "Bullet Duration", 0.1, 5, Settings.Visuals.Effects.BulletDuration, 0.1, function(value) Settings.Visuals.Effects.BulletDuration = value end)
local hitSkeletonToggle, getHitSkeleton = createToggle(effectsSection, "Hit Skeleton", Settings.Visuals.Effects.HitSkeleton, function(value) Settings.Visuals.Effects.HitSkeleton = value end)
local hitSkeletonColorPicker, getHitSkeletonColor = createColorPicker(effectsSection, "Hit Skeleton Color", Theme.EffectHitSkeletonColor, function(color) Theme.EffectHitSkeletonColor = color end)
local skeletonGlowToggleEffect, getSkeletonGlowEffect = createToggle(effectsSection, "Skeleton Glow", Settings.Visuals.Effects.HitSkeletonGlow, function(value) Settings.Visuals.Effects.HitSkeletonGlow = value end)
local skeletonGlowColorPickerEffect, getSkeletonGlowColorEffect = createColorPicker(effectsSection, "Skeleton Glow Color", Theme.EffectHitSkeletonGlowColor, function(color) Theme.EffectHitSkeletonGlowColor = color end)
local crosshairToggle, getCrosshair = createToggle(effectsSection, "Crosshair", Settings.Visuals.Effects.Crosshair, function(value) Settings.Visuals.Effects.Crosshair = value end)
local crosshairColorPicker, getCrosshairColor = createColorPicker(effectsSection, "Crosshair Color", Theme.EffectCrosshairColor, function(color) Theme.EffectCrosshairColor = color end)
local crosshairOutlineToggle, getCrosshairOutline = createToggle(effectsSection, "Crosshair Outline", Settings.Visuals.Effects.CrosshairOutline, function(value) Settings.Visuals.Effects.CrosshairOutline = value end)
local crosshairOutlineColorPicker, getCrosshairOutlineColor = createColorPicker(effectsSection, "Crosshair Outline Color", Theme.EffectCrosshairOutlineColor, function(color) Theme.EffectCrosshairOutlineColor = color end)
local crosshairGapSlider, getCrosshairGap = createSlider(effectsSection, "Crosshair Gap", 0, 20, Settings.Visuals.Effects.CrosshairGap, 1, function(value) Settings.Visuals.Effects.CrosshairGap = value end)
local crosshairSizeSlider, getCrosshairSize = createSlider(effectsSection, "Crosshair Size", 0, 50, Settings.Visuals.Effects.CrosshairSize, 1, function(value) Settings.Visuals.Effects.CrosshairSize = value end)
local crosshairSpinToggle, getCrosshairSpin = createToggle(effectsSection, "Crosshair Spin", Settings.Visuals.Effects.CrosshairSpin, function(value) Settings.Visuals.Effects.CrosshairSpin = value end)
local crosshairSpinSliderSpeed, getCrosshairSpinSpeed = createSlider(effectsSection, "Crosshair Spin Speed", 0, 100, Settings.Visuals.Effects.CrosshairSpinSpeed, 1, function(value) Settings.Visuals.Effects.CrosshairSpinSpeed = value end)


-- Tab 3 - Misc
local miscSubTabs, miscSubTabContent = createSubTabs(miscTabPage, {"Self Misc", "Players"})

-- Subtab 1 - Self Misc
local selfMiscPage = miscSubTabs["Self Misc"].page

-- Section 1 - Fly
local flySection = createSection(selfMiscPage, "Fly")
local flyToggle, _, _, getFlyHotkey, setFlyHotkey = createToggleWithHotkey(flySection, "Toggle", Settings.Misc.Fly.Enable, Settings.Misc.Fly.Hotkey, function(value, hotkey) Settings.Misc.Fly.Enable = value Settings.Misc.Fly.Hotkey = hotkey end)
local flySpeedSlider, getFlySpeed = createSlider(flySection, "Fly Speed", 0, 200, Settings.Misc.Fly.Speed, 1, function(value) Settings.Misc.Fly.Speed = value end)
local flyTypeDropdown, getFlyType = createDropdown(flySection, "Fly Type", {"Normal", "Noclip"}, Settings.Misc.Fly.Type, function(value) Settings.Misc.Fly.Type = value end)

-- Section 2 - Speed
local speedSection = createSection(selfMiscPage, "Speed")
local speedToggle, _, _, getSpeedHotkey, setSpeedHotkey = createToggleWithHotkey(speedSection, "Toggle", Settings.Misc.Speed.Enable, Settings.Misc.Speed.Hotkey, function(value, hotkey) Settings.Misc.Speed.Enable = value Settings.Misc.Speed.Hotkey = hotkey end)
local speedAmountSlider, getSpeedAmount = createSlider(speedSection, "Speed Amount", 0, 200, Settings.Misc.Speed.Amount, 1, function(value) Settings.Misc.Speed.Amount = value end)
local speedTypeDropdown, getSpeedType = createDropdown(speedSection, "Speed Type", {"Unlegit", "Legit"}, Settings.Misc.Speed.Type, function(value) Settings.Misc.Speed.Type = value end)
local legitSlideAmountSlider, getLegitSlideAmount = createSlider(speedSection, "Legit Slide Amount", 0, 100, Settings.Misc.Speed.LegitSlideAmount, 1, function(value) Settings.Misc.Speed.LegitSlideAmount = value end)

-- Section 3 - Anti Aim
local antiAimSection = createSection(selfMiscPage, "Anti Aim")
local antiAimEnableToggle, getAntiAimEnable = createToggle(antiAimSection, "Enable", Settings.Misc.AntiAim.Enable, function(value) Settings.Misc.AntiAim.Enable = value end)
local antiAimTypeDropdown, getAntiAimType = createDropdown(antiAimSection, "Type", {"None", "Fake Down", "Jitter", "Spin"}, Settings.Misc.AntiAim.Type, function(value) Settings.Misc.AntiAim.Type = value end)
local antiAimPitchDropdown, getAntiAimPitch = createDropdown(antiAimSection, "Pitch", {"None", "Down", "Up"}, Settings.Misc.AntiAim.Pitch, function(value) Settings.Misc.AntiAim.Pitch = value end)
local antiAimYawDropdown, getAntiAimYaw = createDropdown(antiAimSection, "Yaw", {"None", "Backward", "Spin", "Jitter"}, Settings.Misc.AntiAim.Yaw, function(value) Settings.Misc.AntiAim.Yaw = value end)
local antiAimRealOffsetSlider, getAntiAimRealOffset = createSlider(antiAimSection, "Real Offset", -180, 180, Settings.Misc.AntiAim.RealOffset, 1, function(value) Settings.Misc.AntiAim.RealOffset = value end)
local antiAimFakeOffsetSlider, getAntiAimFakeOffset = createSlider(antiAimSection, "Fake Offset", -180, 180, Settings.Misc.AntiAim.FakeOffset, 1, function(value) Settings.Misc.AntiAim.FakeOffset = value end)
local antiAimSpinSpeedSlider, getAntiAimSpinSpeed = createSlider(antiAimSection, "Spin Speed", 0, 500, Settings.Misc.AntiAim.SpinSpeed, 1, function(value) Settings.Misc.AntiAim.SpinSpeed = value end)
local antiAimLookAtTargetToggle, getAntiAimLookAtTarget = createToggle(antiAimSection, "Look At Target", Settings.Misc.AntiAim.LookAtTarget, function(value) Settings.Misc.AntiAim.LookAtTarget = value end)
local antiAimJitterToggle, getAntiAimJitter = createToggle(antiAimSection, "Jitter", Settings.Misc.AntiAim.Jitter, function(value) Settings.Misc.AntiAim.Jitter = value end)
local antiAimJitterAmountSlider, getAntiAimJitterAmount = createSlider(antiAimSection, "Jitter Amount", 0, 180, Settings.Misc.AntiAim.JitterAmount, 1, function(value) Settings.Misc.AntiAim.JitterAmount = value end)
local antiAimSpinsToggle, getAntiAimSpins = createToggle(antiAimSection, "Spins", Settings.Misc.AntiAim.Spins, function(value) Settings.Misc.AntiAim.Spins = value end)
local antiAimSpinsSpeedSlider, getAntiAimSpinsSpeed = createSlider(antiAimSection, "Spins Speed", 0, 500, Settings.Misc.AntiAim.SpinSpeed, 1, function(value) Settings.Misc.AntiAim.SpinSpeed = value end)
local antiAimLBYBreakerToggle, getAntiAimLBYBreaker = createToggle(antiAimSection, "LBY Breaker", Settings.Misc.AntiAim.LBYBreaker, function(value) Settings.Misc.AntiAim.LBYBreaker = value end)
local antiAimLBYOffsetSlider, getAntiAimLBYOffset = createSlider(antiAimSection, "LBY Offset", -180, 180, Settings.Misc.AntiAim.LBYOffset, 1, function(value) Settings.Misc.AntiAim.LBYOffset = value end)
local antiAimFakeWalkToggle, getAntiAimFakeWalk = createToggle(antiAimSection, "Fake Walk", Settings.Misc.AntiAim.FakeWalk, function(value) Settings.Misc.AntiAim.FakeWalk = value end)
local antiAimFakeWalkSpeedSlider, getAntiAimFakeWalkSpeed = createSlider(antiAimSection, "Fake Walk Speed", 0, 50, Settings.Misc.AntiAim.FakeWalkSpeed, 1, function(value) Settings.Misc.AntiAim.FakeWalkSpeed = value end)


-- Subtab 2 - Players
local playersPage = miscSubTabs["Players"].page

local playersListSection = createSection(playersPage, "Player List")
local playersContainer = create("Frame", {
    Name = "PlayersContainer",
    BackgroundTransparency = 1,
    Size = UDim2.new(1, 0, 0, 200), -- Fixed height for now
    Parent = playersListSection
})
local playersListLayout = create("UIListLayout", {
    FillDirection = Enum.FillDirection.Vertical,
    HorizontalAlignment = Enum.HorizontalAlignment.Left,
    Padding = UDim.new(0, 5),
    Parent = playersContainer
})

local playerButtons = {}

local function refreshPlayerList()
    for _, btn in pairs(playerButtons) do
        btn:Destroy()
    end
    playerButtons = {}

    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= player then
            local playerButton = create("TextButton", {
                Name = p.Name .. "Button",
                BackgroundColor3 = Settings.Settings.UI.ButtonColor,
                BorderColor3 = Settings.Settings.UI.BorderColor,
                BorderSizePixel = 1,
                Size = UDim2.new(1, 0, 0, 20),
                Text = p.Name,
                TextColor3 = Settings.Settings.UI.PrimaryText,
                TextSize = 12,
                Font = Settings.Settings.UI.Font,
                TextXAlignment = Enum.TextXAlignment.Left,
                Position = UDim2.new(0, 5, 0, 0),
                Parent = playersContainer
            })
            playerButtons[p.Name] = playerButton

            -- Context menu for player actions
            playerButton.MouseButton2Down:Connect(function() -- Right-click for context menu
                local contextMenu = create("Frame", {
                    Name = "PlayerContextMenu",
                    BackgroundColor3 = Settings.Settings.UI.BackgroundColor,
                    BorderColor3 = Settings.Settings.UI.BorderColor,
                    BorderSizePixel = 1,
                    Size = UDim2.new(0, 120, 0, 60),
                    Position = UDim2.new(0, mouse.X - outline.AbsolutePosition.X, 0, mouse.Y - outline.AbsolutePosition.Y),
                    Visible = true,
                    ZIndex = 4,
                    Parent = outline
                })
                local menuLayout = create("UIListLayout", {
                    FillDirection = Enum.FillDirection.Vertical,
                    HorizontalAlignment = Enum.HorizontalAlignment.Left,
                    Padding = UDim.new(0, 2),
                    Parent = contextMenu
                })

                local function createContextButton(text, clickCallback)
                    local btn = create("TextButton", {
                        BackgroundColor3 = Settings.Settings.UI.ButtonColor,
                        BorderColor3 = Settings.Settings.UI.BorderColor,
                        BorderSizePixel = 1,
                        Size = UDim2.new(1, 0, 0, 20),
                        Text = text,
                        TextColor3 = Settings.Settings.UI.PrimaryText,
                        TextSize = 12,
                        Font = Settings.Settings.UI.Font,
                        Parent = contextMenu
                    })
                    btn.MouseButton1Click:Connect(function()
                        clickCallback(p)
                        contextMenu:Destroy()
                    end)
                end

                createContextButton("Spectate", function(targetPlayer)
                    Settings.Misc.Players.SpectatePlayer = targetPlayer.Name
                    showNotification("Spectate", "Spectating: " .. targetPlayer.Name, 2)
                    -- Implement spectate logic here
                end)
                createContextButton("Teleport To", function(targetPlayer)
                    Settings.Misc.Players.TeleportToPlayer = targetPlayer.Name
                    showNotification("Teleport", "Teleporting to: " .. targetPlayer.Name, 2)
                    -- Implement teleport logic here
                    if player.Character and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        player.Character:SetPrimaryPartCFrame(targetPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 5, 0))
                    end
                end)
                createContextButton("Fling", function(targetPlayer)
                    Settings.Misc.Players.FlingPlayer = targetPlayer.Name
                    showNotification("Fling", "Flinging: " .. targetPlayer.Name, 2)
                    -- Implement fling logic here
                    if targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local hrp = targetPlayer.Character.HumanoidRootPart
                        local bv = create("BodyVelocity", {
                            Velocity = Vector3.new(0, 50, 0), -- Upwards fling
                            MaxForce = Vector3.new(math.huge, math.huge, math.huge),
                            Parent = hrp
                        })
                        game:GetService("Debris"):AddItem(bv, 1) -- Fling for 1 second
                    end
                end)

                -- Close context menu if clicked outside
                local closeConnection = UserInputService.InputBegan:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton1 and not input.Target:IsDescendantOf(contextMenu) then
                        contextMenu:Destroy()
                        closeConnection:Disconnect()
                    end
                end)
            end)
        end
    end
end

-- Refresh the player list periodically or on player added/removed events
Players.PlayerAdded:Connect(refreshPlayerList)
Players.PlayerRemoving:Connect(refreshPlayerList)
refreshPlayerList() -- Initial refresh


-- Tab 4 - Settings
local settingsSubTabs, settingsSubTabContent = createSubTabs(settingsTabPage, {"UI", "Config"})

-- Subtab 1 - UI
local uiPage = settingsSubTabs["UI"].page

-- Section 1 - UI
local uiSettingsSection = createSection(uiPage, "UI")

-- UI Element Color Pickers
local uiColors = {
    {"Accent Color", "AccentColor"},
    {"Background Color", "BackgroundColor"},
    {"Surface Color", "SurfaceColor"},
    {"Border Color", "BorderColor"},
    {"Primary Text", "PrimaryText"},
    {"Secondary Text", "SecondaryText"},
    {"Button Color", "ButtonColor"},
    {"Slider Fill Color", "SliderFillColor"},
    {"Toggle Active Color", "ToggleActiveColor"},
    {"Dropdown Color", "DropdownColor"},
    {"Close Button Color", "CloseButtonColor"},
    {"Watermark Color", "WatermarkColor"},
    {"Watermark Pink Color", "WatermarkPinkColor"},
    {"Notification Color", "NotificationColor"},
    {"Glow Color", "GlowColor"},
    {"Tab Active Color", "TabActiveColor"},
    {"Tab Inactive Color", "TabInactiveColor"},
    {"Sub Tab Active Color", "SubTabActiveColor"},
    {"Sub Tab Inactive Color", "SubTabInactiveColor"},
    {"Section Header Color", "SectionHeaderColor"},
    {"Text Box Outline Color", "TextBoxOutlineColor"},
    {"Text Box Fill Color", "TextBoxFillColor"},
    {"Hotkey Button Color", "HotKeyButtonColor"},
}

for _, colorInfo in ipairs(uiColors) do
    local name = colorInfo[1]
    local themeKey = colorInfo[2]
    createColorPicker(uiSettingsSection, name, Theme[themeKey], function(color)
        Theme[themeKey] = color
        -- Update the actual UI elements immediately if possible, or trigger a full refresh
        -- This part would require a more complex UI refresh mechanism or direct property updates
        -- For now, it updates the Theme table.
    end)
end

local guiFontDropdown, getGuiFont = createDropdown(uiSettingsSection, "GUI Font", {"GothamSemibold", "Arial", "SourceSansPro", "Roboto"}, Settings.Settings.UI.Font.Name, function(value) Settings.Settings.UI.Font = Enum.Font[value] end)
local guiBackgroundTransparencySlider, getGuiBackgroundTransparency = createSlider(uiSettingsSection, "GUI Background Transparency", 0, 1, Settings.Settings.UI.BackgroundTransparency, 0.01, function(value)
    Settings.Settings.UI.BackgroundTransparency = value
    indent.BackgroundTransparency = value
    main.BackgroundTransparency = value
    tabContent.BackgroundTransparency = value
    for _, tab in pairs(tabPages) do
        tab.page.BackgroundTransparency = value
    end
end)
local showWatermarkToggle, getShowWatermark = createToggle(uiSettingsSection, "Show Watermark", Settings.Settings.UI.ShowWatermark, function(value)
    Settings.Settings.UI.ShowWatermark = value
    WatermarkFrame.Visible = value
    if value then startWatermarkGlitchCycle() else stopWatermarkGlitchCycle() end
end)
local showNotificationsToggle, getShowNotifications = createToggle(uiSettingsSection, "Show Notifications", Settings.Settings.UI.ShowNotifications, function(value)
    Settings.Settings.UI.ShowNotifications = value
    NotificationContainer.Visible = value
    if value then showNotification("Notifications Enabled", "Notifications are now visible.", 1.5) end
end)

-- Subtab 2 - Config
local configPage = settingsSubTabs["Config"].page

-- Section 1 - Config
local configSection = createSection(configPage, "Config")
local configNameTextBox, getConfigName = createTextBox(configSection, "Config Name", Settings.Settings.Config.ConfigName, function(value) Settings.Settings.Config.ConfigName = value end)
local createConfigToggle, getCreateConfig = createToggle(configSection, "Create Config", Settings.Settings.Config.CreateConfig, function(value)
    Settings.Settings.Config.CreateConfig = value
    if value then
        local configName = getConfigName()
        if configName and configName ~= "" then
            table.insert(Settings.Settings.Config.List, configName)
            showNotification("Config Created", "Config '" .. configName .. "' created.", 1.5)
            setCreateConfig(false) -- Reset toggle
            -- Implement actual config saving logic here (e.g., to DataStoreService or HttpService)
        else
            showNotification("Error", "Config name cannot be empty.", 1.5, Color3.fromRGB(255, 0, 0))
            setCreateConfig(false)
        end
    end
end)

local loadConfigToggle, getLoadConfig = createToggle(configSection, "Load Config", Settings.Settings.Config.LoadConfig, function(value)
    Settings.Settings.Config.LoadConfig = value
    if value then
        local configName = getConfigName()
        if table.find(Settings.Settings.Config.List, configName) then
            showNotification("Config Loaded", "Config '" .. configName .. "' loaded.", 1.5)
            Settings.Settings.Config.Current = configName
            setLoadConfig(false) -- Reset toggle
            -- Implement actual config loading logic here
        else
            showNotification("Error", "Config '" .. configName .. "' not found.", 1.5, Color3.fromRGB(255, 0, 0))
            setLoadConfig(false)
        end
    end
end)

local deleteConfigToggle, getDeleteConfig = createToggle(configSection, "Delete Config", Settings.Settings.Config.DeleteConfig, function(value)
    Settings.Settings.Config.DeleteConfig = value
    if value then
        local configName = getConfigName()
        local index = table.find(Settings.Settings.Config.List, configName)
        if index then
            table.remove(Settings.Settings.Config.List, index)
            if Settings.Settings.Config.Current == configName then
                Settings.Settings.Config.Current = "Default" -- Reset current if deleted
            end
            showNotification("Config Deleted", "Config '" .. configName .. "' deleted.", 1.5)
            setDeleteConfig(false) -- Reset toggle
            -- Implement actual config deletion logic here
        else
            showNotification("Error", "Config '" .. configName .. "' not found.", 1.5, Color3.fromRGB(255, 0, 0))
            setDeleteConfig(false)
        end
    end
end)

local configListLabel = create("TextLabel", {
    BackgroundTransparency = 1,
    Size = UDim2.new(1, 0, 0, 20),
    Text = "Available Configs: " .. table.concat(Settings.Settings.Config.List, ", "),
    TextColor3 = Settings.Settings.UI.SecondaryText,
    TextSize = 12,
    Font = Settings.Settings.UI.Font,
    TextXAlignment = Enum.TextXAlignment.Left,
    TextWrapped = true,
    Parent = configSection
})

-- Implement custom ESP drawing functions
local function updateESP()
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= player and p.Character and p.Character:FindFirstChild("Humanoid") and p.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = p.Character.Humanoid
            local hrp = p.Character.HumanoidRootPart
            local head = p.Character:FindFirstChild("Head")

            local espObject = ESPObjects[p]
            if not espObject then
                espObject = {}
                espObject.Box = create("Frame", {
                    BackgroundTransparency = 1,
                    BorderSizePixel = 0,
                    Size = UDim2.new(0, 100, 0, 100),
                    ZIndex = 2,
                    Parent = ESPContainer
                })
                espObject.NameLabel = create("TextLabel", {
                    BackgroundTransparency = 1,
                    Size = UDim2.new(0, 100, 0, 20),
                    ZIndex = 2,
                    Parent = espObject.Box -- Child of box for relative positioning
                })
                espObject.HealthBarBG = create("Frame", {
                    BackgroundTransparency = 1,
                    BorderSizePixel = 1,
                    ZIndex = 2,
                    Parent = espObject.Box
                })
                espObject.HealthBarFill = create("Frame", {
                    BackgroundTransparency = 0,
                    BorderSizePixel = 0,
                    ZIndex = 3,
                    Parent = espObject.HealthBarBG
                })
                espObject.HealthNumberLabel = create("TextLabel", {
                    BackgroundTransparency = 1,
                    Size = UDim2.new(1, 0, 1, 0),
                    ZIndex = 4,
                    TextColor3 = Theme.ESPHealthNumberColor,
                    Font = Settings.Settings.UI.Font,
                    TextSize = 10,
                    TextXAlignment = Enum.TextXAlignment.Center,
                    Parent = espObject.HealthBarBG
                })
                espObject.ToolLabel = create("TextLabel", {
                    BackgroundTransparency = 1,
                    Size = UDim2.new(0, 100, 0, 20),
                    ZIndex = 2,
                    Parent = espObject.Box
                })
                espObject.DistanceLabel = create("TextLabel", {
                    BackgroundTransparency = 1,
                    Size = UDim2.new(0, 100, 0, 20),
                    ZIndex = 2,
                    Parent = espObject.Box
                })
                -- Add more GUI elements as needed for Chams, Skeleton, etc. (more complex rendering)
                -- For Chams and Skeleton, usually involves manipulating actual MeshParts or drawing on a canvas,
                -- which is beyond simple GUI elements. For this example, we'll keep them as simple toggles
                -- indicating the feature is "on" and assume a backend system handles the visual effect.
                ESPObjects[p] = espObject
            end

            -- Calculate screen position and size
            local rootPos, isOnScreen = camera:WorldToScreenPoint(hrp.Position)
            if not isOnScreen or (rootPos.Z < 0 and camera.FieldOfView ~= 0) then -- Also check for Z for objects behind camera
                espObject.Box.Visible = false
                continue
            end

            local headPos = head and camera:WorldToScreenPoint(head.Position)
            
            local boxWidth = 100 -- Arbitrary initial size
            local boxHeight = 200

            if head and hrp then
                local headScreenPos = camera:WorldToScreenPoint(head.Position)
                local rootScreenPos = camera:WorldToScreenPoint(hrp.Position)

                -- Calculate box dimensions based on screen positions and character size
                -- This is a simplified calculation and can be improved for accuracy
                boxHeight = math.abs(headScreenPos.Y - rootScreenPos.Y) * 1.5 -- Scale based on vertical distance
                boxWidth = boxHeight * 0.5 -- Aspect ratio
                if boxHeight < 50 then boxHeight = 50 end -- Minimum size
                if boxWidth < 25 then boxWidth = 25 end

                local boxX = rootScreenPos.X - boxWidth / 2
                local boxY = headScreenPos.Y - (boxHeight * 0.1) -- Position slightly above head
                
                espObject.Box.Position = UDim2.new(0, boxX, 0, boxY)
                espObject.Box.Size = UDim2.new(0, boxWidth, 0, boxHeight)
            else
                 -- Fallback if head/hrp not found, center on rootPos
                espObject.Box.Position = UDim2.new(0, rootPos.X - boxWidth / 2, 0, rootPos.Y - boxHeight / 2)
                espObject.Box.Size = UDim2.new(0, boxWidth, 0, boxHeight)
            end

            espObject.Box.Visible = Settings.Visuals.ESP.Enable and (hrp.Position - player.Character.HumanoidRootPart.Position).Magnitude <= Settings.Visuals.ESP.Distance

            if espObject.Box.Visible then
                -- Box ESP
                local boxFrame = espObject.Box:FindFirstChild("BoxFrame") or create("Frame", {
                    Name = "BoxFrame",
                    BackgroundTransparency = 1,
                    BorderSizePixel = 1,
                    BorderColor3 = Theme.ESPBoxColor,
                    Size = UDim2.new(1, 0, 1, 0),
                    Parent = espObject.Box
                })
                boxFrame.Visible = Settings.Visuals.ESP.BoxESP
                boxFrame.BorderColor3 = Theme.ESPBoxColor
                
                -- Box Glow
                local boxGlow = espObject.Box:FindFirstChild("BoxGlow") or create("UIStroke", {
                    Name = "BoxGlow",
                    ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                    Color = Theme.ESPBoxGlowColor,
                    Transparency = 0.5, -- Adjust as needed
                    Thickness = 2,
                    Parent = boxFrame
                })
                boxGlow.Enabled = Settings.Visuals.ESP.BoxGlow
                boxGlow.Color = Theme.ESPBoxGlowColor

                -- Name ESP
                espObject.NameLabel.Visible = Settings.Visuals.ESP.NameESP
                espObject.NameLabel.Text = p.Name
                espObject.NameLabel.TextColor3 = Theme.ESPNameColor
                espObject.NameLabel.Position = UDim2.new(0, 0, 0, -20) -- Above the box
                espObject.NameLabel.Size = UDim2.new(1, 0, 0, 20)
                
                -- Name Text Outline
                local nameStroke = espObject.NameLabel:FindFirstChild("NameStroke") or create("UIStroke", {
                    Name = "NameStroke",
                    ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
                    Color = Theme.ESPNameOutlineColor,
                    Thickness = 1,
                    Parent = espObject.NameLabel
                })
                nameStroke.Enabled = Settings.Visuals.ESP.NameOutline
                nameStroke.Color = Theme.ESPNameOutlineColor

                -- Name Glow (TextLabel.TextStrokeTransparency simulates glow, or use UIStroke)
                local nameTextGlow = espObject.NameLabel:FindFirstChild("NameTextGlow") or create("UIStroke", {
                    Name = "NameTextGlow",
                    ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
                    Color = Theme.ESPNameGlowColor,
                    Thickness = 2,
                    Transparency = 0.5,
                    Parent = espObject.NameLabel
                })
                nameTextGlow.Enabled = Settings.Visuals.ESP.NameGlow
                nameTextGlow.Color = Theme.ESPNameGlowColor

                -- Health Bar ESP
                espObject.HealthBarBG.Visible = Settings.Visuals.ESP.HealthBarESP
                if Settings.Visuals.ESP.HealthBarESP then
                    local healthRatio = humanoid.Health / humanoid.MaxHealth
                    local healthBarHeight = boxHeight * healthRatio
                    espObject.HealthBarBG.Size = UDim2.new(0, 5, 1, 0) -- Fixed width, same height as box
                    espObject.HealthBarBG.Position = UDim2.new(0, -7, 0, 0) -- Left of the box
                    espObject.HealthBarBG.BackgroundColor3 = Theme.ESPHealthBarBGColor
                    espObject.HealthBarBG.BorderColor3 = Theme.ESPHealthBarOutlineColor
                    espObject.HealthBarFill.BackgroundColor3 = Theme.ESPHealthBarColor
                    espObject.HealthBarFill.Size = UDim2.new(1, 0, 0, healthBarHeight)
                    espObject.HealthBarFill.Position = UDim2.new(0, 0, 1, -healthBarHeight) -- Fill from bottom up
                    
                    espObject.HealthBarBG.BorderSizePixel = Settings.Visuals.ESP.HealthBarOutline and 1 or 0

                    if Settings.Visuals.ESP.HealthNumber then
                        espObject.HealthNumberLabel.Visible = true
                        espObject.HealthNumberLabel.Text = math.floor(humanoid.Health)
                        espObject.HealthNumberLabel.TextColor3 = Theme.ESPHealthNumberColor
                    else
                        espObject.HealthNumberLabel.Visible = false
                    end

                    -- Health Bar Glow
                    local healthStroke = espObject.HealthBarBG:FindFirstChild("HealthStroke") or create("UIStroke", {
                        Name = "HealthStroke",
                        ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                        Color = Theme.ESPHealthBarGlowColor,
                        Thickness = 1,
                        Transparency = 0.5,
                        Parent = espObject.HealthBarBG
                    })
                    healthStroke.Enabled = Settings.Visuals.ESP.HealthBarGlow
                    healthStroke.Color = Theme.ESPHealthBarGlowColor
                else
                    espObject.HealthNumberLabel.Visible = false
                end

                -- Tool ESP
                espObject.ToolLabel.Visible = Settings.Visuals.ESP.ToolESP
                local currentTool = p.Character:FindFirstChildOfClass("Tool")
                if currentTool then
                    espObject.ToolLabel.Text = currentTool.Name
                    espObject.ToolLabel.TextColor3 = Theme.ESPToolColor
                    espObject.ToolLabel.Position = UDim2.new(0, 0, 1, 0) -- Below the box
                    espObject.ToolLabel.Size = UDim2.new(1, 0, 0, 20)

                    local toolStroke = espObject.ToolLabel:FindFirstChild("ToolStroke") or create("UIStroke", {
                        Name = "ToolStroke",
                        ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
                        Color = Theme.ESPToolOutlineColor,
                        Thickness = 1,
                        Parent = espObject.ToolLabel
                    })
                    toolStroke.Enabled = Settings.Visuals.ESP.ToolOutline
                    toolStroke.Color = Theme.ESPToolOutlineColor

                    local toolTextGlow = espObject.ToolLabel:FindFirstChild("ToolTextGlow") or create("UIStroke", {
                        Name = "ToolTextGlow",
                        ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
                        Color = Theme.ESPToolGlowColor,
                        Thickness = 2,
                        Transparency = 0.5,
                        Parent = espObject.ToolLabel
                    })
                    toolTextGlow.Enabled = Settings.Visuals.ESP.ToolGlow
                    toolTextGlow.Color = Theme.ESPToolGlowColor
                else
                    espObject.ToolLabel.Text = ""
                end

                -- Distance ESP
                espObject.DistanceLabel.Visible = Settings.Visuals.ESP.DistanceESP
                local distance = math.floor((hrp.Position - player.Character.HumanoidRootPart.Position).Magnitude)
                espObject.DistanceLabel.Text = tostring(distance) .. "m"
                espObject.DistanceLabel.TextColor3 = Theme.ESPDistanceColor
                espObject.DistanceLabel.Position = UDim2.new(0, 0, 1, 20) -- Below tool, or below box if no tool
                espObject.DistanceLabel.Size = UDim2.new(1, 0, 0, 20)
                
                local distanceStroke = espObject.DistanceLabel:FindFirstChild("DistanceStroke") or create("UIStroke", {
                    Name = "DistanceStroke",
                    ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
                    Color = Theme.ESPDistanceOutlineColor,
                    Thickness = 1,
                    Parent = espObject.DistanceLabel
                })
                distanceStroke.Enabled = Settings.Visuals.ESP.DistanceOutline
                distanceStroke.Color = Theme.ESPDistanceOutlineColor

                local distanceTextGlow = espObject.DistanceLabel:FindFirstChild("DistanceTextGlow") or create("UIStroke", {
                    Name = "DistanceTextGlow",
                    ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
                    Color = Theme.ESPDistanceGlowColor,
                    Thickness = 2,
                    Transparency = 0.5,
                    Parent = espObject.DistanceLabel
                })
                distanceTextGlow.Enabled = Settings.Visuals.ESP.DistanceGlow
                distanceTextGlow.Color = Theme.ESPDistanceGlowColor

                -- Chams and Skeleton would involve more complex 3D rendering or mesh manipulation
                -- We'll assume these are toggles for a backend system to handle.
            else
                espObject.Box.Visible = false
            end

        else
            if ESPObjects[p] then
                ESPObjects[p].Box:Destroy()
                ESPObjects[p] = nil
            end
        end
    end
end

-- Update Self ESP (simplified as it's just for the local player)
local SelfESPBox = nil
local SelfESPNameLabel = nil
local SelfESPHealthBarBG = nil
local SelfESPHealthBarFill = nil
local SelfESPHealthNumberLabel = nil
local SelfESPToolLabel = nil
local SelfESPDistanceLabel = nil

local function updateSelfESP()
    if not player.Character or not player.Character:FindFirstChild("Humanoid") or not player.Character:FindFirstChild("HumanoidRootPart") then
        if SelfESPBox then SelfESPBox.Visible = false end
        return
    end

    local humanoid = player.Character.Humanoid
    local hrp = player.Character.HumanoidRootPart
    local head = player.Character:FindFirstChild("Head")

    if not SelfESPBox then
        SelfESPBox = create("Frame", {
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            Size = UDim2.new(0, 100, 0, 100),
            ZIndex = 2,
            Parent = ESPContainer
        })
        SelfESPNameLabel = create("TextLabel", {
            BackgroundTransparency = 1,
            Size = UDim2.new(0, 100, 0, 20),
            ZIndex = 2,
            Parent = SelfESPBox
        })
        SelfESPHealthBarBG = create("Frame", {
            BackgroundTransparency = 1,
            BorderSizePixel = 1,
            ZIndex = 2,
            Parent = SelfESPBox
        })
        SelfESPHealthBarFill = create("Frame", {
            BackgroundTransparency = 0,
            BorderSizePixel = 0,
            ZIndex = 3,
            Parent = SelfESPHealthBarBG
        })
        SelfESPHealthNumberLabel = create("TextLabel", {
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 1, 0),
            ZIndex = 4,
            TextColor3 = Theme.SelfESPHealthNumberColor,
            Font = Settings.Settings.UI.Font,
            TextSize = 10,
            TextXAlignment = Enum.TextXAlignment.Center,
            Parent = SelfESPHealthBarBG
        })
        SelfESPToolLabel = create("TextLabel", {
            BackgroundTransparency = 1,
            Size = UDim2.new(0, 100, 0, 20),
            ZIndex = 2,
            Parent = SelfESPBox
        })
        SelfESPDistanceLabel = create("TextLabel", {
            BackgroundTransparency = 1,
            Size = UDim2.new(0, 100, 0, 20),
            ZIndex = 2,
            Parent = SelfESPBox
        })
    end

    local rootPos, isOnScreen = camera:WorldToScreenPoint(hrp.Position)
    if not isOnScreen or (rootPos.Z < 0 and camera.FieldOfView ~= 0) then
        SelfESPBox.Visible = false
        return
    end

    local headPos = head and camera:WorldToScreenPoint(head.Position)
    local boxWidth = 100
    local boxHeight = 200

    if head and hrp then
        local headScreenPos = camera:WorldToScreenPoint(head.Position)
        local rootScreenPos = camera:WorldToScreenPoint(hrp.Position)

        boxHeight = math.abs(headScreenPos.Y - rootScreenPos.Y) * 1.5
        boxWidth = boxHeight * 0.5
        if boxHeight < 50 then boxHeight = 50 end
        if boxWidth < 25 then boxWidth = 25 end

        local boxX = rootScreenPos.X - boxWidth / 2
        local boxY = headScreenPos.Y - (boxHeight * 0.1)
        
        SelfESPBox.Position = UDim2.new(0, boxX, 0, boxY)
        SelfESPBox.Size = UDim2.new(0, boxWidth, 0, boxHeight)
    else
        SelfESPBox.Position = UDim2.new(0, rootPos.X - boxWidth / 2, 0, rootPos.Y - boxHeight / 2)
        SelfESPBox.Size = UDim2.new(0, boxWidth, 0, boxHeight)
    end

    SelfESPBox.Visible = Settings.Visuals.SelfESP.Enable

    if SelfESPBox.Visible then
        -- Box ESP
        local boxFrame = SelfESPBox:FindFirstChild("BoxFrame") or create("Frame", {
            Name = "BoxFrame",
            BackgroundTransparency = 1,
            BorderSizePixel = 1,
            BorderColor3 = Theme.SelfESPBoxColor,
            Size = UDim2.new(1, 0, 1, 0),
            Parent = SelfESPBox
        })
        boxFrame.Visible = Settings.Visuals.SelfESP.BoxESP
        boxFrame.BorderColor3 = Theme.SelfESPBoxColor
        
        local boxGlow = SelfESPBox:FindFirstChild("BoxGlow") or create("UIStroke", {
            Name = "BoxGlow",
            ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
            Color = Theme.SelfESPBoxGlowColor,
            Transparency = 0.5,
            Thickness = 2,
            Parent = boxFrame
        })
        boxGlow.Enabled = Settings.Visuals.SelfESP.BoxGlow
        boxGlow.Color = Theme.SelfESPBoxGlowColor

        -- Name ESP
        SelfESPNameLabel.Visible = Settings.Visuals.SelfESP.NameESP
        SelfESPNameLabel.Text = player.Name
        SelfESPNameLabel.TextColor3 = Theme.SelfESPNameColor
        SelfESPNameLabel.Position = UDim2.new(0, 0, 0, -20)
        SelfESPNameLabel.Size = UDim2.new(1, 0, 0, 20)
        
        local nameStroke = SelfESPNameLabel:FindFirstChild("NameStroke") or create("UIStroke", {
            Name = "NameStroke",
            ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
            Color = Theme.SelfESPNameOutlineColor,
            Thickness = 1,
            Parent = SelfESPNameLabel
        })
        nameStroke.Enabled = Settings.Visuals.SelfESP.NameOutline
        nameStroke.Color = Theme.SelfESPNameOutlineColor

        local nameTextGlow = SelfESPNameLabel:FindFirstChild("NameTextGlow") or create("UIStroke", {
            Name = "NameTextGlow",
            ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
            Color = Theme.SelfESPNameGlowColor,
            Thickness = 2,
            Transparency = 0.5,
            Parent = SelfESPNameLabel
        })
        nameTextGlow.Enabled = Settings.Visuals.SelfESP.NameGlow
        nameTextGlow.Color = Theme.SelfESPNameGlowColor

        -- Health Bar ESP
        SelfESPHealthBarBG.Visible = Settings.Visuals.SelfESP.HealthBarESP
        if Settings.Visuals.SelfESP.HealthBarESP then
            local healthRatio = humanoid.Health / humanoid.MaxHealth
            local healthBarHeight = boxHeight * healthRatio
            SelfESPHealthBarBG.Size = UDim2.new(0, 5, 1, 0)
            SelfESPHealthBarBG.Position = UDim2.new(0, -7, 0, 0)
            SelfESPHealthBarBG.BackgroundColor3 = Theme.SelfESPHealthBarBGColor
            SelfESPHealthBarBG.BorderColor3 = Theme.SelfESPHealthBarOutlineColor
            SelfESPHealthBarFill.BackgroundColor3 = Theme.SelfESPHealthBarColor
            SelfESPHealthBarFill.Size = UDim2.new(1, 0, 0, healthBarHeight)
            SelfESPHealthBarFill.Position = UDim2.new(0, 0, 1, -healthBarHeight)
            
            SelfESPHealthBarBG.BorderSizePixel = Settings.Visuals.SelfESP.HealthBarOutline and 1 or 0

            if Settings.Visuals.SelfESP.HealthNumber then
                SelfESPHealthNumberLabel.Visible = true
                SelfESPHealthNumberLabel.Text = math.floor(humanoid.Health)
                SelfESPHealthNumberLabel.TextColor3 = Theme.SelfESPHealthNumberColor
            else
                SelfESPHealthNumberLabel.Visible = false
            end

            local healthStroke = SelfESPHealthBarBG:FindFirstChild("HealthStroke") or create("UIStroke", {
                Name = "HealthStroke",
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                Color = Theme.SelfESPHealthBarGlowColor,
                Thickness = 1,
                Transparency = 0.5,
                Parent = SelfESPHealthBarBG
            })
            healthStroke.Enabled = Settings.Visuals.SelfESP.HealthBarGlow
            healthStroke.Color = Theme.SelfESPHealthBarGlowColor
        else
            SelfESPHealthNumberLabel.Visible = false
        end

        -- Tool ESP
        SelfESPToolLabel.Visible = Settings.Visuals.SelfESP.ToolESP
        local currentTool = player.Character:FindFirstChildOfClass("Tool")
        if currentTool then
            SelfESPToolLabel.Text = currentTool.Name
            SelfESPToolLabel.TextColor3 = Theme.SelfESPToolColor
            SelfESPToolLabel.Position = UDim2.new(0, 0, 1, 0)
            SelfESPToolLabel.Size = UDim2.new(1, 0, 0, 20)

            local toolStroke = SelfESPToolLabel:FindFirstChild("ToolStroke") or create("UIStroke", {
                Name = "ToolStroke",
                ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
                Color = Theme.SelfESPToolOutlineColor,
                Thickness = 1,
                Parent = SelfESPToolLabel
            })
            toolStroke.Enabled = Settings.Visuals.SelfESP.ToolOutline
            toolStroke.Color = Theme.SelfESPToolOutlineColor

            local toolTextGlow = SelfESPToolLabel:FindFirstChild("ToolTextGlow") or create("UIStroke", {
                Name = "ToolTextGlow",
                ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
                Color = Theme.SelfESPToolGlowColor,
                Thickness = 2,
                Transparency = 0.5,
                Parent = SelfESPToolLabel
            })
            toolTextGlow.Enabled = Settings.Visuals.SelfESP.ToolGlow
            toolTextGlow.Color = Theme.SelfESPToolGlowColor
        else
            SelfESPToolLabel.Text = ""
        end

        -- Distance ESP (from camera to self)
        SelfESPDistanceLabel.Visible = Settings.Visuals.SelfESP.DistanceESP
        local distance = math.floor((hrp.Position - camera.CFrame.Position).Magnitude)
        SelfESPDistanceLabel.Text = tostring(distance) .. "m"
        SelfESPDistanceLabel.TextColor3 = Theme.SelfESPDistanceColor
        SelfESPDistanceLabel.Position = UDim2.new(0, 0, 1, 20)
        SelfESPDistanceLabel.Size = UDim2.new(1, 0, 0, 20)
        
        local distanceStroke = SelfESPDistanceLabel:FindFirstChild("DistanceStroke") or create("UIStroke", {
            Name = "DistanceStroke",
            ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
            Color = Theme.SelfESPDistanceOutlineColor,
            Thickness = 1,
            Parent = SelfESPDistanceLabel
        })
        distanceStroke.Enabled = Settings.Visuals.SelfESP.DistanceOutline
        distanceStroke.Color = Theme.SelfESPDistanceOutlineColor

        local distanceTextGlow = SelfESPDistanceLabel:FindFirstChild("DistanceTextGlow") or create("UIStroke", {
            Name = "DistanceTextGlow",
            ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
            Color = Theme.SelfESPDistanceGlowColor,
            Thickness = 2,
            Transparency = 0.5,
            Parent = SelfESPDistanceLabel
        })
        distanceTextGlow.Enabled = Settings.Visuals.SelfESP.DistanceGlow
        distanceTextGlow.Color = Theme.SelfESPDistanceGlowColor

        -- Chams for self (assume backend implementation)
    else
        SelfESPBox.Visible = false
    end
end


RunService.RenderStepped:Connect(function()
    updateESP()
    updateSelfESP()
    -- Other rendering updates for FOV, tracers, crosshair etc.
end)


-- Initial GUI state
screenGui.Enabled = true

-- Example: Toggle GUI visibility with a keybind (e.g., RightControl)
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if not gameProcessedEvent and input.KeyCode == Enum.KeyCode.RightControl then
        screenGui.Enabled = not screenGui.Enabled
        if screenGui.Enabled then
            showNotification("UI Opened", "Welcome back!", 2)
        end
    end
end)

-- Make the main GUI draggable
makeDraggable(outline, outline2) -- Drag by the black border or main outline

-- Functions for actual game features (simplified/placeholders)

-- Aimbot Logic (simplified)
local function getTarget()
    local bestTarget = nil
    local shortestDistance = math.huge
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= player and p.Character and p.Character:FindFirstChild("Humanoid") and p.Character:FindFirstChild("HumanoidRootPart") and p.Character.Humanoid.Health > 0 then
            local distance = (p.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                bestTarget = p
            end
        end
    end
    return bestTarget
end

RunService.Heartbeat:Connect(function()
    if Settings.Combat.Enable and getAimbotHotkey()() and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local target = getTarget()
        if target and target.Character and target.Character:FindFirstChild(Settings.Combat.HitPart) then
            local targetPart = target.Character:FindFirstChild(Settings.Combat.HitPart)
            local targetPosition = targetPart.Position

            -- Apply prediction
            if Settings.Combat.UsePrediction then
                local targetVelocity = target.Character:FindFirstChild("HumanoidRootPart") and target.Character.HumanoidRootPart.Velocity or Vector3.new(0,0,0)
                targetPosition = targetPosition + targetVelocity * Settings.Combat.XPredictionAmount
            end

            -- Apply custom offset
            if Settings.Combat.UseCustomOffset then
                targetPosition = targetPosition + Vector3.new(Settings.Combat.XOffset, Settings.Combat.YOffset, 0)
            end

            if Settings.Combat.AimType == "Mouse" then
                -- Direct mouse manipulation (usually requires exploits)
                -- For legitimate client-sided aim, this would involve CFrame manipulation
                local screenPos, onScreen = camera:WorldToScreenPoint(targetPosition)
                if onScreen then
                    -- This is conceptual; actual mouse movement is restricted in Roblox.
                    -- An actual aimbot would involve setting mouse.Hit or camera.CFrame
                    -- to look at the target, which is usually patched or detected.
                    -- For a simple visual, we'd aim the camera.
                    local direction = (targetPosition - camera.CFrame.Position).Unit
                    camera.CFrame = CFrame.new(camera.CFrame.Position, camera.CFrame.Position + direction)
                end
            elseif Settings.Combat.AimType == "Camera" then
                local currentCFrame = camera.CFrame
                local targetCFrame = CFrame.new(currentCFrame.Position, targetPosition)

                if Settings.Combat.UseSmoothness then
                    local alpha = 1 - (Settings.Combat.XSmoothnessAmount / 100) -- Convert smoothness to alpha for Lerp
                    camera.CFrame = currentCFrame:Lerp(targetCFrame, alpha)
                else
                    camera.CFrame = targetCFrame
                end
            end
        end
    end

    -- Silent Aim Logic (simplified)
    if Settings.Combat.SilentAim.Enable and getSilentAimHotkey()() and player.Character then
        local target = getTarget()
        if target and target.Character then
            local hitPart = nil
            for _, partName in ipairs(Settings.Combat.SilentAim.HitParts) do
                hitPart = target.Character:FindFirstChild(partName) or target.Character:FindFirstChild(partName:gsub(" ", "")) -- Try with/without space
                if hitPart then break end
            end

            if hitPart and (not Settings.Combat.SilentAim.WallCheck or not isVisuallyObscured(player.Character.HumanoidRootPart, hitPart, {})) and
               (not Settings.Combat.SilentAim.TeamCheck or player.TeamColor ~= target.TeamColor) then
                if Settings.Combat.SilentAim.HitChanceToggle and math.random(1, 100) > Settings.Combat.SilentAim.HitChance then
                    -- Miss intentionally
                else
                    -- Assume a system where this "silent aim" event triggers a hit regardless of where the client's mouse is pointing
                    -- In a real game, this would involve sending spoofed raycasts or remote events.
                    -- This is highly likely to be detected by anti-cheats.
                    -- For demonstration, we'll just show a notification.
                    -- showNotification("Silent Aim", "Attempting to hit " .. target.Name .. " at " .. (hitPart and hitPart.Name or "unknown part"), 0.5)
                end
            end
        end
    end

    -- Orbit Lock Logic (simplified)
    if Settings.Combat.OrbitLock.Enable and getOrbitLockHotkey()() and player.Character and currentTarget then
        local hrp = currentTarget.Character and currentTarget.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            orbitAngle = orbitAngle + Settings.Combat.OrbitLock.Speed
            local offset = CFrame.Angles(0, math.rad(orbitAngle), 0) * Vector3.new(Settings.Combat.OrbitLock.Radius, Settings.Combat.OrbitLock.YOffset, 0)

            player.Character:SetPrimaryPartCFrame(hrp.CFrame * CFrame.new(offset))

            if Settings.Combat.OrbitLock.LookAtTarget then
                local currentCamCFrame = camera.CFrame
                local targetLookCFrame = CFrame.new(currentCamCFrame.Position, hrp.Position)
                camera.CFrame = currentCamCFrame:Lerp(targetLookCFrame, 0.5) -- Smooth look
            end
        end
    end

    -- Fun features (simplified)
    if Settings.Combat.HitNotification and currentTarget and currentTarget.Humanoid.Health <= 0 then -- Simplified hit detection
        local soundId = HIT_SOUND_IDS[Settings.Combat.HitSound]
        if soundId then
            local sound = create("Sound", {
                SoundId = soundId,
                Parent = SoundService
            })
            sound:Play()
            sound.Ended:Connect(function() sound:Destroy() end)
        end
        showNotification("Hit!", "You hit " .. currentTarget.Name .. "!", 1, Theme.AccentColor)
        currentTarget = nil -- Reset target after "hit"
    end

    -- Visuals Effects
    if Settings.Visuals.Effects.SnowFlakes then
        -- Spawn snow particles (conceptual)
        -- local particleEmitter = create("ParticleEmitter", {
        --     Texture = SNOWFLAKE_EFFECT_ID,
        --     LightEmission = 1,
        --     Lifetime = NumberRange.new(5, 10),
        --     Rate = 10,
        --     Size = NumberSequence.new(0.5, 2),
        --     Speed = NumberRange.new(5, 15),
        --     Parent = camera
        -- })
        -- game:GetService("Debris"):AddItem(particleEmitter, 0.1)
    end
    if Settings.Visuals.Effects.HelloKitty then
        -- Spawn hello kitty particles (conceptual)
        -- local particleEmitter = create("ParticleEmitter", {
        --     Texture = HELLO_KITTY_EFFECT_ID,
        --     LightEmission = 1,
        --     Lifetime = NumberRange.new(5, 10),
        --     Rate = 5,
        --     Size = NumberSequence.new(0.5, 2),
        --     Speed = NumberRange.new(5, 15),
        --     Parent = camera
        -- })
        -- game:GetService("Debris"):AddItem(particleEmitter, 0.1)
    end

    -- Crosshair drawing (conceptual - requires custom drawing or manipulating an ImageLabel)
    if Settings.Visuals.Effects.Crosshair then
        -- This would involve creating a custom crosshair GUI element and updating its properties
        -- based on settings like size, gap, spin, color, etc.
        -- For simplicity, we assume a CrosshairFrame exists in screenGui
        local crosshairFrame = screenGui:FindFirstChild("CrosshairFrame")
        if not crosshairFrame then
            crosshairFrame = create("Frame", {
                Name = "CrosshairFrame",
                BackgroundTransparency = 1,
                Size = UDim2.new(0, 50, 0, 50),
                AnchorPoint = Vector2.new(0.5, 0.5),
                Position = UDim2.new(0.5, 0, 0.5, 0),
                ZIndex = 5,
                Parent = screenGui
            })
            -- Add inner crosshair lines
            local line1 = create("Frame", {BackgroundColor3 = Theme.EffectCrosshairColor, Size = UDim2.new(0, 20, 0, 2), Position = UDim2.new(0.5, -10, 0.5, -1), Parent = crosshairFrame})
            local line2 = create("Frame", {BackgroundColor3 = Theme.EffectCrosshairColor, Size = UDim2.new(0, 2, 0, 20), Position = UDim2.new(0.5, -1, 0.5, -10), Parent = crosshairFrame})
        end
        crosshairFrame.Visible = true
        crosshairFrame.Size = UDim2.new(0, Settings.Visuals.Effects.CrosshairSize * 2, 0, Settings.Visuals.Effects.CrosshairSize * 2)
        
        -- Apply gap
        for _, child in ipairs(crosshairFrame:GetChildren()) do
            if child:IsA("Frame") then
                if child.Name == "line1" then -- Horizontal
                    child.Position = UDim2.new(0.5, -Settings.Visuals.Effects.CrosshairSize + Settings.Visuals.Effects.CrosshairGap, 0.5, -1)
                    child.Size = UDim2.new(0, Settings.Visuals.Effects.CrosshairSize * 2 - Settings.Visuals.Effects.CrosshairGap * 2, 0, 2)
                elseif child.Name == "line2" then -- Vertical
                    child.Position = UDim2.new(0.5, -1, 0.5, -Settings.Visuals.Effects.CrosshairSize + Settings.Visuals.Effects.CrosshairGap)
                    child.Size = UDim2.new(0, 2, 0, Settings.Visuals.Effects.CrosshairSize * 2 - Settings.Visuals.Effects.CrosshairGap * 2)
                end
                child.BackgroundColor3 = Theme.EffectCrosshairColor
                local stroke = child:FindFirstChildOfClass("UIStroke") or create("UIStroke", {Parent = child, ApplyStrokeMode = Enum.ApplyStrokeMode.Border})
                stroke.Enabled = Settings.Visuals.Effects.CrosshairOutline
                stroke.Color = Theme.EffectCrosshairOutlineColor
            end
        end

        if Settings.Visuals.Effects.CrosshairSpin then
            crosshairFrame.Rotation = (crosshairFrame.Rotation + Settings.Visuals.Effects.CrosshairSpinSpeed) % 360
        else
            crosshairFrame.Rotation = 0
        end

    else
        local crosshairFrame = screenGui:FindFirstChild("CrosshairFrame")
        if crosshairFrame then crosshairFrame.Visible = false end
    end
end)

-- Misc features (simplified)
RunService.Heartbeat:Connect(function()
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        local humanoid = player.Character.Humanoid
        -- Fly
        if Settings.Misc.Fly.Enable then
            -- This requires more advanced character manipulation or a custom character controller.
            -- For simplicity, we'll set the humanoid's states.
            humanoid.PlatformStand = true
            player.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0) -- Stop falling
            if UserInputService:IsKeyDown(Settings.Misc.Fly.Hotkey) then
                if Settings.Misc.Fly.Type == "Normal" then
                    player.Character:SetPrimaryPartCFrame(player.Character.PrimaryPart.CFrame * CFrame.new(0, Settings.Misc.Fly.Speed / 60, 0))
                elseif Settings.Misc.Fly.Type == "Noclip" then
                    -- Noclip requires setting CanCollide to false for all parts, or using a BodyMover that bypasses collision.
                    for _, part in ipairs(player.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                    player.Character:SetPrimaryPartCFrame(player.Character.PrimaryPart.CFrame * camera.CFrame.LookVector * Settings.Misc.Fly.Speed / 60)
                end
            end
        else
            humanoid.PlatformStand = false
            -- Reset noclip parts if previously enabled
            for _, part in ipairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") and not part.Anchored then
                    part.CanCollide = true
                end
            end
        end

        -- Speed
        if Settings.Misc.Speed.Enable then
            if Settings.Misc.Speed.Type == "Legit" then
                humanoid.WalkSpeed = originalWalkSpeed + Settings.Misc.Speed.Amount
                -- Legit slide: Requires custom movement code to add sliding
            else -- Unlegit
                humanoid.WalkSpeed = Settings.Misc.Speed.Amount
            end
        else
            humanoid.WalkSpeed = originalWalkSpeed
        end

        -- Anti-Aim (Highly complex and often patched/detected)
        if Settings.Misc.AntiAim.Enable then
            -- This requires manipulating the player's CFrame or Humanoid.BodyOrientation
            -- to make them look in a different direction than their actual camera.
            -- This is a placeholder for the logic.
        end
    end
end)
